<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>多线程编程 | xzw の 的个人博客</title><meta name="author" content="xzw"><meta name="copyright" content="xzw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多线程编程线程概念 Linux下线程的本质: LWP(light weight process) 轻量级的进程,本质仍然是进程(在Linux环境下) 进程: 有独立的进程地址空间,有独立的PCB 线程: 有独立的PCB,但是没有独立的地址空间(共享) 区别: 在于是否共享地址空间   独居(进程)  合租(线程) Linux下: 线程: 最小的执行单位 进程: 最小的分配资源的单位,可以看成只有一">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程编程">
<meta property="og:url" content="https://xzwsloser.github.io/2024/08/29/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="xzw の 的个人博客">
<meta property="og:description" content="多线程编程线程概念 Linux下线程的本质: LWP(light weight process) 轻量级的进程,本质仍然是进程(在Linux环境下) 进程: 有独立的进程地址空间,有独立的PCB 线程: 有独立的PCB,但是没有独立的地址空间(共享) 区别: 在于是否共享地址空间   独居(进程)  合租(线程) Linux下: 线程: 最小的执行单位 进程: 最小的分配资源的单位,可以看成只有一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img0.baidu.com/it/u=2423843250,176201309&fm=253&fmt=auto?w=500&h=500">
<meta property="article:published_time" content="2024-08-29T15:44:15.621Z">
<meta property="article:modified_time" content="2024-08-29T15:45:29.308Z">
<meta property="article:author" content="xzw">
<meta property="article:tag" content="多线程编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img0.baidu.com/it/u=2423843250,176201309&fm=253&fmt=auto?w=500&h=500"><link rel="shortcut icon" href="/img/touxiang.webp"><link rel="canonical" href="https://xzwsloser.github.io/2024/08/29/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '多线程编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-29 23:45:29'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="xzw の 的个人博客"><img class="site-icon" src="/img/touxiang.webp"/><span class="site-name">xzw の 的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">多线程编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-29T15:44:15.621Z" title="发表于 2024-08-29 23:44:15">2024-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-29T15:45:29.308Z" title="更新于 2024-08-29 23:45:29">2024-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/">C++ 后台开发</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">Linux系统编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="多线程编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><ul>
<li><code>Linux</code>下线程的本质: <code>LWP</code>(<code>light weight process</code>) 轻量级的进程,本质仍然是进程(在<code>Linux</code>环境下)</li>
<li>进程: 有独立的进程地址空间,有独立的<code>PCB</code></li>
<li>线程: 有独立的<code>PCB</code>,但是没有独立的地址空间(共享)</li>
<li>区别: 在于是否共享地址空间   独居(进程)  合租(线程)</li>
<li><code>Linux</code>下:<ul>
<li>线程: 最小的执行单位</li>
<li>进程: 最小的分配资源的单位,可以看成只有一个线程的进程</li>
</ul>
</li>
<li>当利用 <code>creat</code> 函数创建线程之后,进程就会退化成线程</li>
<li>所以对于并发执行的进程,如果开启更多的线程,那么就会由更多的线程来抢夺<code>cpu</code>的执行权利这就使得该进程有更多的机会执行,但是并不是线程越多执行机会越多<br><img src="/img/image%20copy.png" alt="alt text"></li>
<li>可以使用<code>ps -Lf 进程ID</code> 来查看进程的线程号(不是线程<code>ID</code>),线程号 –&gt; <code>cpu</code>执行的最小单位</li>
</ul>
<h3 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h3><ul>
<li>注意以下几点:<ul>
<li>轻量级进程,也有<code>PCB</code>,创建线程使用的底层函数和进程一样,都是<code>clone</code></li>
<li>从内核里面看进程和线程都是一样的,都有各自不同的<code>PCB</code>,但是<code>PCB</code>中执行内存资源的三级页表是相同的</li>
<li>进程可以蜕变成线程</li>
<li>线程可以看成寄存器和栈的集合</li>
<li>在<code>linux</code>下,线程是最小的执行单位,进程是最小的分配资源的单位</li>
</ul>
</li>
<li>实际上,在一个进程中的用户空间中存储的变量并不是直接通过<code>MMU</code>映射到真实的物理内存空间,而是首先借助<code>PCB</code>中的指针,这一个指针指向一个页目录,页目录中的指针指向页表,页表中的指针指向物理页面,物理页面存在着真实的目录内存,由于创建线程的过程底层其实就是调用了<code>clone</code>方法,所以他的<code>pcb</code>中的指针和原来的进程的<code>pcb</code>中的指针一样,所以指向同样一块内存地址空间</li>
<li>三级映射: 进程<code>PCB</code> –&gt; 页目录(可以看成数组,首地址位于<code>PCB</code>中) –&gt; 页表 –&gt; 物理页面 —&gt; 内存单元</li>
</ul>
<h3 id="线程的共享和非共享"><a href="#线程的共享和非共享" class="headerlink" title="线程的共享和非共享"></a>线程的共享和非共享</h3><ul>
<li>线程共享资源:<ul>
<li>文件描述符号表</li>
<li>每一种信号的处理方式</li>
<li>当前工作目录</li>
<li>用户<code>ID</code>和组<code>ID</code></li>
<li>内存地址空间(<code>.text</code> <code>./data</code> <code>.bss</code> <code>heap</code> 共享库)(没有栈)</li>
</ul>
</li>
<li>线程非共享资源:<ul>
<li>线程<code>id</code></li>
<li>处理器线程和栈指针(内核栈)</li>
<li>独立的栈空间(用户栈空间)</li>
<li><code>errorno</code>变量(是一个全局变量)</li>
<li>信号屏蔽字</li>
<li>调度优先级</li>
</ul>
</li>
<li>优点: <ol>
<li>提高程序并法性 </li>
<li>开销比较小</li>
<li>数据通信,共享数据方便</li>
</ol>
</li>
<li>缺点：<ol>
<li>库函数,不稳定</li>
<li>调试,编写困难,<code>gdb</code>不支持</li>
<li>对于信号支持不好</li>
</ol>
</li>
<li><code>Linux</code>下实现方法导致进程,线程差别不是特别大</li>
</ul>
<h2 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h4><ul>
<li>作用: 获取线程<code>ID</code></li>
<li>头文件: <code>&lt;pthread.h&gt;</code></li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li>返回值: 返回线程<code>ID</code></li>
<li>注意线程<code>ID</code>用于在一个进程中标记线程,在<code>Linux</code>本质就是<code>lu</code>的别名,其他的系统中使用结构体的方式实现,线程<code>ID</code>是线程内部的识别标志</li>
</ul>
<h4 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h4><ul>
<li><p>作用: 创建新的线程</p>
</li>
<li><p>函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *<span class="keyword">restrict</span> thread,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *<span class="keyword">restrict</span> arg)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历的时候需要链接 <code>pthread</code> 库</p>
</li>
<li><p>参数:</p>
<ul>
<li><code>thread</code>: 传出参数,作用就是可以带出线程<code>ID</code></li>
<li><code>attr</code>: 表示设置线程的属性,一般传入<code>NULL</code>表示传入默认属性</li>
<li><code>start_routine</code>: 表示需要传入的执行函数(参数和返回值都是泛型类型)</li>
<li><code>arg</code>: 表示函数的参数</li>
</ul>
</li>
<li><p>演示<code>demo</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="comment">// 子线程的回调函数</span></span><br><span class="line"><span class="comment">// 注意回调函数的类型 (void*)(*func)(void*)</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">my_func</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取进程号和线程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: pid = %d , tid = %lu \n&quot;</span> , getpid() , pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 pthread_self 获取线程 ID</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    tid = pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid  = %lu \n&quot;</span> , tid);  <span class="comment">// 相当于独享进程空间的线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %d \n&quot;</span> , getpid());</span><br><span class="line">    <span class="comment">// 使用 pthread_create创建线程</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid , <span class="literal">NULL</span> , my_func , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;create a thread failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: pid: %d , tid: %lu \n&quot;</span> , getpid() , pthread_self());</span><br><span class="line">    <span class="comment">// 需要让主线程阻塞等待一段时间</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意得到的结果中,<code>main</code>和<code>pthread</code>的<code>pid</code>一样但是<code>tid</code>不一样</p>
</li>
<li><p>由于需要传入的函数必须是<code>void*(*func)(void*)</code>类型,所以如果需要传入各种参数那么就需要定义结构体来作为传入参数,函数会被自动调用</p>
</li>
</ul>
<h4 id="循环创建子线程"><a href="#循环创建子线程" class="headerlink" title="循环创建子线程"></a>循环创建子线程</h4><ul>
<li>如果使用以下代码循环创建子线程:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">print_pthread</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = *((<span class="type">int</span>*)args); <span class="comment">// void* 类型相当于泛型,可以传递各种类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pthread %d: pid - %d , tid - %lu \n&quot;</span> , i + <span class="number">1</span>, getpid() , pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环创建多个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret , i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">        ret = pthread_create(&amp;tid , <span class="literal">NULL</span> , print_pthread , (<span class="type">void</span>*)&amp;i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;create thread failed !!! \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: pid - %d , tid - %lu \n&quot;</span> , getpid() , pthread_self());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>就会发生如下结果:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread 4: pid - 88902 , tid - 124829323757248 </span><br><span class="line">pthread 5: pid - 88902 , tid - 124829334243008 </span><br><span class="line">pthread 5: pid - 88902 , tid - 124829313271488 </span><br><span class="line">pthread 5: pid - 88902 , tid - 124829302785728 </span><br><span class="line">main: pid - 88902 , tid - 124829340292928 </span><br><span class="line">pthread 6: pid - 88902 , tid - 124829292299968 </span><br></pre></td></tr></table></figure></li>
<li>错误原因分析: 以上代码中,由于<code>main</code>函数和不同的线程有不同的栈帧,<code>main</code>函数的栈帧中存在变量<code>i</code>,如果使用地址传递的方式传递参数,就会导致此时线程的栈中的变量指向<code>main</code>函数的栈中的变量,但是<code>main</code>函数中的变量在不断变化,所以就会造成以上结果</li>
<li>所以最好在创建子线程的时候,使用值拷贝的方式传递参数</li>
<li>这里的<code>void*</code>尽管可以当成一个可以转换为任意数据类型的泛型(类似于<code>go</code>中的空接口类型),<code>void*</code>占用<code>8</code>个字节,<code>int</code>占用<code>4</code>个字节所以转换的时候不会造成精度的缺失</li>
<li>各种类型占用的空间如下,注意指针占用<code>8</code>个字节(<code>64</code>位编译器):<br><img src="/img/image%20copy%202.png" alt="alt text"></li>
<li>这里解释以下为什么说<code>64</code>位操作系统中<code>int</code>占用<code>8</code>个字节:<ul>
<li>注意这里的<code>int</code>并不是指的就是<code>int</code>,而是<code>int</code>类型的变量,比如<code>long</code>等,<code>long</code>在<code>32</code>位操作系统中占用<code>4</code>个字节但是在<code>64</code>位操作系统中占用 <code>8</code> 个字节,位数不同的操作系统的寻址能力不同,体现与指针的位数,比如<code>64</code>位操作系统中的寻址范围就是 $2^64$ 所以指针就占用 <code>8</code> 个字节也就是 <code>64</code>个<code>bit</code></li>
</ul>
</li>
<li>正确代码如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">print_pthread</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)args; <span class="comment">// void* 类型相当于泛型,可以传递各种类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pthread %d: pid - %d , tid - %lu \n&quot;</span> , i + <span class="number">1</span>, getpid() , pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环创建多个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret , i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">        ret = pthread_create(&amp;tid , <span class="literal">NULL</span> , print_pthread , (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;create thread failed !!! \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: pid - %d , tid - %lu \n&quot;</span> , getpid() , pthread_self());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="线程和共享"><a href="#线程和共享" class="headerlink" title="线程和共享"></a>线程和共享</h4><ul>
<li>线程之间共享全局变量<ul>
<li>线程默认共享数据段,代码段的呢个地址空间,常用的就是全局变量,但是进程不会共享全局变量,只可以借助<code>mmap</code>(进程中遵循读时共享,写时复制的原则,其实就是建立了副本)</li>
</ul>
</li>
<li>注意共享的含义就是子线程改变变量,父线程中的数据也会进行相同的改变</li>
<li>验证:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> var = <span class="number">20</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">pthread_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    var = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: var = %d \n&quot;</span> , var);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid ;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_create(&amp;tid , <span class="literal">NULL</span> , pthread_handler , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;creat thread failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: var = %d \n&quot;</span> , var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意<code>C</code> 语言中各个内存区域和作用:<br><img src="/img/image%20copy%203.png" alt="alt text"></li>
</ul>
<h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h3><ul>
<li>作用: 线程退出</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">noreturn</span>]] <span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数: <code>retval</code> 表示传出参数,用于承载子线程中返回值</li>
<li>为什么使用 <code>pthread_exit</code>,这是由于<code>exit</code>用于退出整个进程,而不是退出线程, <code>return</code>表示返回给函数调用者</li>
<li>利用<code>pthread_exit</code>退出只是将线程退出,并且不会影响其他进程</li>
<li>各种退出效果总结如下:<ul>
<li><code>return</code> 返回到调用者那里去</li>
<li><code>pthread_exit</code> 将调用该函数的线程退出</li>
<li><code>exit</code> 退出它的进程</li>
</ul>
</li>
<li>三者的对比如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 演示 return exit pthread_exit 三者之间的区别</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">pthread_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// exit(0);  // 表示退出当前进程</span></span><br><span class="line">        <span class="comment">// return NULL; 返回给函数的调用这</span></span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 表示退出线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The %d th thread , tid: %ld \n&quot;</span> , i + <span class="number">1</span> , pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">        ret = pthread_create(&amp;tid , <span class="literal">NULL</span> , pthread_handler , (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;create thread failed !!! \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sleep(1);</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);  <span class="comment">// 表示退出父进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h3><ul>
<li>作用: 阻塞等待线程退出,获取线程退出状态,其作用就是对应于进程中的<code>waitpid()</code>函数</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数:<ul>
<li><code>thread</code> 表示需要回收的线程<code>ID</code></li>
<li><code>retval</code> 表示获取函数的退出状态(需要回收<code>void*</code>)(比如进程的退出值就是<code>pid</code>)(注意这里的设计逻辑,如果返回值是<code>int</code>类型,那么就需要使用 <code>int*</code> 类型回收返回值,如果返回值是<code>void*</code>类型,那么就需要使用<code>void**</code>回收返回值)(参考<code>wait</code>函数使用<code>&amp;status</code>作为传出参数)</li>
</ul>
</li>
<li>注意<code>pthread_join</code>会阻塞等待</li>
<li>另外一个小的知识点,注意指针只有分配了内存空间才可以使用常量赋值,但是如果没有分配内存空间还是可以使用指针或者地址赋值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">p = <span class="string">&quot;123&quot;</span>;<span class="comment">// error</span></span><br><span class="line"><span class="type">char</span>* p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);</span><br><span class="line">p = <span class="string">&quot;hello&quot;</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line"><span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">p = &amp;k <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
<li><code>pthread_join</code>使用方式如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于传递的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thrd</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span>* <span class="title">ret_val</span>;</span></span><br><span class="line">    ret_val = (<span class="keyword">struct</span> thrd*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> thrd));</span><br><span class="line">    ret_val -&gt; var = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 注意常量无法使用 = 进行赋值操作</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ret_val -&gt; name , <span class="string">&quot;hello thread!!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)ret_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_create(&amp;tid , <span class="literal">NULL</span> , thread_handler , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;create thread failed !!! &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行回收</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span>* <span class="title">res</span>;</span></span><br><span class="line">    ret = pthread_join(tid , (<span class="type">void</span>**)&amp;res); <span class="comment">// 注意参数</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;resouce my child failed !!!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var = %d , name = %s \n&quot;</span> , res -&gt; var , res -&gt; name);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>需要注意的事项如下:<ul>
<li>在线程执行的函数中,不要返回一个局部变量的地址(此时这个函数的栈帧已经被销毁了,返回一个没有意义的栈地址)</li>
<li>可以在<code>main</code>函数中定义一个变量,之后在线程的执行函数中操作这一个变量,这是由于函数执行完了之后<code>main</code>函数的栈地址仍然存在依然可用</li>
</ul>
</li>
<li>以下情况也正确但是还是最好在堆区开启空间:</li>
<li>可以返回局部变量的值,但是不可以返回局部变量的地址<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于传递的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thrd</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span>* <span class="title">ret_val</span> =</span> (<span class="keyword">struct</span> thrd*) arg;</span><br><span class="line">    <span class="comment">// ret_val = (struct thrd*) malloc (sizeof(struct thrd));</span></span><br><span class="line">    ret_val -&gt; var = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 注意常量无法使用 = 进行赋值操作</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ret_val -&gt; name , <span class="string">&quot;hello thread!!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* thread_handler(void* arg)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return (void*)100;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span>* <span class="title">arg</span>;</span></span><br><span class="line">    ret = pthread_create(&amp;tid , <span class="literal">NULL</span> , thread_handler , (<span class="type">void</span>*)arg);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;create thread failed !!! &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行回收</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span>* <span class="title">res</span>;</span></span><br><span class="line">    <span class="comment">// int res;</span></span><br><span class="line">    ret = pthread_join(tid , (<span class="type">void</span>**)&amp;res); <span class="comment">// 注意参数</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;resouce my child failed !!!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var = %d , name = %s \n&quot;</span> , res -&gt; var , res -&gt; name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var = %d , name = %s \n&quot;</span> , arg -&gt; var , arg -&gt; name);</span><br><span class="line">    <span class="comment">// printf(&quot;var = %d \n&quot; , res);</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>连续: 循环创建多个子线程并且回收:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the %d th child , my tid is %ld \n&quot;</span> , i + <span class="number">1</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环创建多个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">        ret = pthread_create(&amp;tid[i] , <span class="literal">NULL</span> , thread_handler , (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;create thread failed !!! &quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环退出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">        ret = pthread_join(tid[i] , <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Successfully resource my child: %d \n&quot;</span> , i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h3><ul>
<li>作用: 用于杀死线程</li>
<li>函数原型如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数:<ul>
<li><code>thread</code> 表示需要杀死的进程<code>ID</code></li>
</ul>
</li>
<li>注意利用 <code>pthread_cancel</code> 把进程杀死的时候</li>
<li>注意利用<code>pthread_cancel</code>杀死进程的时候进入内核,需要进入内核的契机,如果子进程一直执行就没有取消点了,如果没有保存点,那么就可以使用<code>pthread_testcancel()</code>来设置取消点</li>
<li>成功被 <code>pthread_cancel</code>杀死的线程,返回<code>-1</code>,可以使用<code>pthread_join</code>回收这一个值</li>
<li>演示<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;I am the child , tid : %ld \n&quot; , pthread_self());</span></span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        pthread_testcancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 利用 pthread_cancel 杀死线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid , <span class="literal">NULL</span> , thread_handler , <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 杀死线程</span></span><br><span class="line">    ret = pthread_cancel(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;can not canel this thread !!!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行线程的回收</span></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    ret = pthread_join(tid , (<span class="type">void</span>**)&amp;res);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;resource thread failed !!!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit code is %d \n&quot;</span> , res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h3><ul>
<li>作用: 实现线程分离,让线程脱离与主线程而存在</li>
<li>函数原型如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数:<ul>
<li>线程号</li>
</ul>
</li>
<li>对于线程中出现的错误,不可以使用 <code>perror</code> 进行打印,这是由于无法翻译错误条件,可以使用 <code>strerror(errno)</code> 结合 <code>fprintf</code> 进行错误处理即可</li>
<li>注意即检测出错返回的方式 !!!<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建子线程任务</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[thread]   pid : %ld \n&quot;</span> , pthread_self());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid  , <span class="literal">NULL</span> , thread_handler , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 注意错误处理方式</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create thread failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;detach thread failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_join(tid , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// perror(&quot;resource thread failed !!!&quot;);</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;resource thread failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="进程控制原语和线程控制原语的区别"><a href="#进程控制原语和线程控制原语的区别" class="headerlink" title="进程控制原语和线程控制原语的区别"></a>进程控制原语和线程控制原语的区别</h3><ul>
<li>创建: <code>fork</code>  <code>pthread_create</code></li>
<li>回收: <code>wait waitpid</code> <code>pthread_join</code></li>
<li>杀死: <code>kill</code> <code>pthread_cancel</code></li>
<li>获取信息: <code>getpid()</code>  <code>pthread_self</code></li>
<li>退出: <code>pthread_exit</code> <code>exit</code></li>
</ul>
<h2 id="线程属性设置分离线程"><a href="#线程属性设置分离线程" class="headerlink" title="线程属性设置分离线程"></a>线程属性设置分离线程</h2><ul>
<li>线程属性就是创建线程时候的第二个参数</li>
<li>早期的<code>Linux kernel</code>中的线程状态结构体:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> etachstate; <span class="comment">// 线程的分离状态</span></span><br><span class="line">    <span class="type">int</span> schedpolicy; <span class="comment">// 线程调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">schedparam</span>;</span> <span class="comment">// 线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched; <span class="comment">// 线程的继承性</span></span><br><span class="line">    <span class="type">int</span> scope; <span class="comment">// 线程的作用域</span></span><br><span class="line">    <span class="type">size_t</span> guardsize; <span class="comment">// 线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="type">int</span> stackaddr_set; <span class="comment">// 线程栈的设置</span></span><br><span class="line">    <span class="type">void</span>* stackaddr; <span class="comment">// 线程栈的位置</span></span><br><span class="line">    <span class="type">size_t</span> stacksize; <span class="comment">// 线程栈的大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置线程的分离状态"><a href="#设置线程的分离状态" class="headerlink" title="设置线程的分离状态"></a>设置线程的分离状态</h3><ul>
<li>注意设置线程分离状态的好处: 不用回收线程,线程执行完之后自动就可以被回收了</li>
<li>线程属性初始化,使用如下两个函数:</li>
<li><code>pthread_attr_init</code> 用于初始化线程属性</li>
<li><code>pthread_attr_destory</code> 销毁线程属性所占用的资源</li>
<li>注意这两个函数的作用就是操作线程属性而不是操作线程<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="分离状态以及非分离状态"><a href="#分离状态以及非分离状态" class="headerlink" title="分离状态以及非分离状态"></a>分离状态以及非分离状态</h4><ul>
<li>非分离状态: 线程默认的属性就是非分离状态,这一种情况下,原有的线程等待创建的线程结束,只有当<code>pthread_join</code>函数返回的时候,创建的线程才算终止,才可以释放自己占用的系统资源</li>
<li>分离状态: 分离线程没有被其他的线程等待,自己运行结束了,线程也终止了,马上释放系统资源,应该根据自己的需要,选择适当的分离状态</li>
<li>设置线程分离的函数: <code>pthread_attr_setdetachstate</code></li>
<li>查看线程分离状态的函数: <code>pthread_attr_getdetachstate</code></li>
<li>参数(detachstate):<ul>
<li><code>PTHREAD_CREATE_DETACHED</code>(分离线程)</li>
<li><code>PTHREAD_CREATE_JOINABLE</code> (非分离线程)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> *detachstate)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>演示<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[thread] pid : %ld \n &quot;</span> , pthread_self());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">int</span> ret = pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;init attr failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置分离</span></span><br><span class="line">    ret = pthread_attr_setdetachstate(&amp;attr , PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;detach thread failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看</span></span><br><span class="line">    <span class="type">int</span> detachstate;</span><br><span class="line">    pthread_attr_getdetachstate(&amp;attr , &amp;detachstate);</span><br><span class="line">    <span class="keyword">if</span>(detachstate == PTHREAD_CREATE_DETACHED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Successfully set status !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    ret = pthread_create(&amp;tid , &amp;attr , thread_handler , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create thread failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回收线程</span></span><br><span class="line">    ret = pthread_join(tid , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;resource thread failed : %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;destroy attr failed : %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>总结:<ul>
<li>定义线程属性</li>
<li>初始化线程属性</li>
<li>设置线程属性为分离状态</li>
<li>借助修改之后的线程属性来创建分离态的线程</li>
<li>回收看是否分离成功</li>
</ul>
</li>
</ul>
<h3 id="线程的使用注意事项"><a href="#线程的使用注意事项" class="headerlink" title="线程的使用注意事项"></a>线程的使用注意事项</h3><ol>
<li>主线程退出其他线程不退出,主线程需要调用<code>pthread_exit</code>方法</li>
<li>避免僵尸线程: <code>pthread_join</code>  <code>pthread_detach</code>  <code>pthread_create</code>指定分离属性,被<code>join</code>线程会受到线程在回收之前可能就释放完了自己的所有内存资源,所以不应当返回被回收线程栈中的值</li>
<li><code>malloc</code>和<code>mmap</code>申请的内存可以被其他线程释放(共享堆区)</li>
<li>需要避免在多线程模型中调用<code>fork</code>,除非马上<code>exec</code>,子进程只有调用<code>fork</code>的进程存在,其他进程在子进程中都需要使用<code>pthread_exit</code></li>
<li>信号的复杂语义很难和多线程共存,应该避免在多线程中引入信号机制</li>
</ol>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li>线程同步,指的就是一个线程发生功能调用的瞬间,在没有得到结果之前,该调用不用返回 同时其他线程为保证数据一致性,不能调用该功能</li>
<li>多个线程同时操作一个共享变量的时候就需要进行进程同步操作(比如取钱的时候,如果一个线程作了判断之后另外的线程也进来对于数据进行操作,那么就会导致两个线程都对于这一个数据进行了操作,但还是以为只有一个变量对于数据进行了操作导致出错)</li>
<li>数据混乱的原因:<ul>
<li>资源共享(独享资源则不会)</li>
<li>调度随机(意味着数据访问会出现竞争)</li>
<li>线程之间缺乏必要的同步机制</li>
</ul>
</li>
</ul>
<h3 id="利用互斥锁进行线程同步"><a href="#利用互斥锁进行线程同步" class="headerlink" title="利用互斥锁进行线程同步"></a>利用互斥锁进行线程同步</h3><h4 id="互斥量-mutex"><a href="#互斥量-mutex" class="headerlink" title="互斥量(mutex)"></a>互斥量(mutex)</h4><ul>
<li>也就是互斥锁,作用就是利用互斥锁锁住全局变量,那么就可以保证公共资源每一次只会被一个线程进行操作,但是如果某一个线程直接访问全局变量那还是会导致数据不同布的问题,所以这些解决线程同步问题使用的锁都是建议锁而不是强制锁</li>
<li>锁的使用:<ul>
<li>建议锁,用于锁住全局变量,锁住全局变量之后,就只有一个线程可以操作全局变量</li>
</ul>
</li>
</ul>
<h5 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h5><ul>
<li>需要使用的函数如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init 函数</span><br><span class="line">pthread_mutex_destory 函数</span><br><span class="line">pthread_mutex_lock 函数</span><br><span class="line">pthread_mutex_trylock 函数</span><br><span class="line">pthread_mutex_unlock 函数</span><br></pre></td></tr></table></figure></li>
<li>以上几个函数的返回值都是: 成功返回 <code>0</code> , 失败返回错误号</li>
<li>关注以下几个类型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> 类型 本质是一个结构体,为了简化理解,应用的时候可以忽略实现细节,简单当成整数看待</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex; 变量 mutext只有两种取值: `<span class="number">0</span>` 和 `<span class="number">1</span>`</span><br></pre></td></tr></table></figure></li>
<li>使用锁的步骤:<ol>
<li><code>pthread_mutex_t lock</code> 创建锁</li>
<li><code>pthread_mutex_init</code>  初始化</li>
<li><code>pthread_mutex_lock</code> 加锁</li>
<li>操作全局变量</li>
<li><code>pthread_mutex_unlock</code> 解锁</li>
<li><code>pthread_mutex_destroy</code> 销毁锁</li>
</ol>
</li>
</ul>
<h6 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a>pthread_mutex_init函数</h6><ul>
<li>作用: 初始化锁 </li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>参数:<ul>
<li><code>mutex</code> 表示锁</li>
<li><code>attr</code> 表示锁相关的配置</li>
</ul>
</li>
<li>成功返回 <code>0</code> 失败返回 <code>errorno</code></li>
<li><code>restrict</code>关键字用于限定指针变量,被该关键字限定的指针变量所指向的内存操作,必须由本指针完成</li>
</ul>
<h6 id="pthread-mutex-destory函数"><a href="#pthread-mutex-destory函数" class="headerlink" title="pthread_mutex_destory函数"></a>pthread_mutex_destory函数</h6><ul>
<li>作用: 销毁锁</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数: <ul>
<li>表示需要释放的锁</li>
</ul>
</li>
</ul>
<h6 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a>pthread_mutex_lock函数</h6><ul>
<li>作用: 加锁</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数: <ul>
<li>表示所加上的锁</li>
</ul>
</li>
<li>成功返回<code>0</code>,失败返回<code>errorno</code></li>
</ul>
<h6 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a>pthread_mutex_unlock函数</h6><ul>
<li>作用: 解锁</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数: …</li>
<li>返回值: …</li>
<li>进行互斥锁操作的<code>demo</code>如下:</li>
<li>这里操作的全局变量就是 <code>stdout</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 子线程需要执行的操作</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;world \n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 随机时间种子</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 初始化锁</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_mutex_init(&amp;mutex , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;init mutex failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid , <span class="literal">NULL</span> , thread_handler , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create thread failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HELLO &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WORLD \n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;destory mutex failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用技巧: 注意<code>mutex</code>的位置,不要再锁操作的代码中进行休眠,否则很容易导致某一个线程不断执行某一个业务逻辑,长时间占用 <code>CPU</code></li>
<li><strong>一定需要注意锁的粒度,越小越好(访问共享数据之前加锁,访问结束之后立刻解锁)</strong> </li>
<li><code>mutex</code>类型可以看成<code>int</code>类型,初始化之后可以看作<code>mutex = 1</code> <code>lock</code> 可以想象成<code>mutex --</code>  同时<code>unlock</code>可以想象成 <code>mutex++</code>,虽然本质就是结构体,但是这样利于学习</li>
<li>对于<code>mutex</code>的操作:<ul>
<li>加锁: <code>--</code>操作,阻塞线程</li>
<li>解锁: <code>++</code>操作,唤醒阻塞在锁上的线程</li>
<li><code>try</code>锁: 尝试加锁,成功<code>++</code>,失败返回(注意此时不会阻塞,设置错误号为 <code>EBUSY</code>)</li>
</ul>
</li>
<li><code>try</code>锁使用<code>pthread_mutex_trylock</code>函数</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>不是一种锁,而是一种现象,是使用锁不恰当而导致的错误</li>
<li>会产生死锁的现象:<ul>
<li>对于一个锁反复<code>lock</code>(自己把自己锁住了)</li>
<li>两个线程各自持有一把锁,都在请求另外一把锁</li>
</ul>
</li>
<li>两种现象的解释如下:<br><img src="/img/Screenshot_20240828_220318_tv.danmaku.bilibilihd.jpg" alt="alt text"></li>
<li>第一种情况的死锁:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex; <span class="comment">// 模拟死锁</span></span><br><span class="line"><span class="type">int</span> var = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span>(var &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[thread] tid = %ld , var = %d  \n&quot;</span> , pthread_self() , var);</span><br><span class="line">        var ++;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_mutex_init(&amp;mutex , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;init mutex error: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid , <span class="literal">NULL</span> , thread_handler , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create mutex error: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞回收</span></span><br><span class="line">    ret = pthread_join(tid , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;join mutex error: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    ret = pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;destory mutex error: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>第二种情况的死锁:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_b;</span><br><span class="line"><span class="type">int</span> var1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> var2 = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_handler1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(var1 &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex_a);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex_b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[thread] tid = %ld , var1 = %d \n &quot;</span> , pthread_self() , var1);</span><br><span class="line">        var1 ++;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_b);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_handler2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(var2 &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex_b);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex_a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[thread] tid = %ld , var1 = %d \n &quot;</span> , pthread_self() , var2);</span><br><span class="line">        var2 ++;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_mutex_init(&amp;mutex_a , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;init mutex_a failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pthread_mutex_init(&amp;mutex_b , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;init mutex_b failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;tid[<span class="number">0</span>] , <span class="literal">NULL</span> , thread_handler1 , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create thread_a failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;tid[<span class="number">1</span>] , <span class="literal">NULL</span> , thread_handler2 , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create thread_b failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span> ; i ++)&#123;</span><br><span class="line">        ret = pthread_join(tid[i] , <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot; join thread failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    ret = pthread_mutex_destroy(&amp;mutex_a);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;destory thread_a failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pthread_mutex_destroy(&amp;mutex_b);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;destory thread_b failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li>与互斥锁类似,但是读写锁允许更高的并型性,他的特性为: 写独占,读共享</li>
<li>注意特点:<ul>
<li><strong>读共享,写独占</strong></li>
<li><strong>写锁优先级高</strong></li>
<li><strong>只有一把锁</strong></li>
</ul>
</li>
<li>使用读的方式给数据加锁–读锁,以写的方式给数据加锁–写锁</li>
<li>注意如果一个线程已经拿到锁了,就算是写锁的线程也会被阻塞,拿不到锁</li>
<li>这里思考以下为什么写锁的优先级别高,这是由于只有在写锁之后,读取到的数据才是真正的数据,避免了”读未提交的问题”</li>
<li>这里介绍几种情况,<code>Tn</code> 表示每一个线程 <code>n</code> 表示线程的顺序,<code>n</code>越小表示顺序越靠前:<ul>
<li>如果 <code>T1</code> 为 <code>r</code> <code>T2</code>为<code>w</code> 那么<code>T2</code>就会获取锁</li>
<li>如果<code>T1</code> 为 <code>r</code> 并且已经获取到锁了,如果<code>T2</code>为<code>w</code>,那么<code>T2</code> 还是会被阻塞,这是由于此时锁已经被获取了</li>
<li>如果<code>T1</code> 为 <code>r</code> 并且获取了锁 , <code>T2</code> 为 <code>r</code> <code>T3</code> 为<code>w</code> 由于此时 <code>T3</code> 和 <code>T2</code> 都没有获取到锁,所以此时更具写锁优先级别高的元素应该是 <code>T3</code> 首先拿到锁,之后 <code>T2</code> 拿到进行数据的读取</li>
</ul>
</li>
</ul>
<h4 id="读写锁特性"><a href="#读写锁特性" class="headerlink" title="读写锁特性"></a>读写锁特性</h4><ol>
<li>读写锁是 “写模式加锁” 时,解锁之前,所有对该解锁加锁的线程都会被阻塞</li>
<li>读写锁是”读模式加锁” 时,如果线程使用读模式对其加锁成功,如果线程以写模式则会阻塞</li>
<li>读写锁时 “读模式加锁” 时,既有试图使用写模式加锁的线程,也有试图使用读模式加锁的线程,那么读写锁会阻塞随后的读模式锁请求,优先满足写模式锁,<strong>读锁写锁并行阻塞,但是写锁的优先级别高于读锁</strong></li>
</ol>
<ul>
<li>读写锁也叫做共享-独占锁,当读写锁使用读模式锁住的时候,它是使用共享模式锁住的,当它使用写模式锁住的时候,它是使用独占模式锁住的,<strong>写独占,读共享</strong></li>
<li>读写锁非常适合于对于数据结构的读的次数远大于写的次数</li>
</ul>
<h4 id="读写锁的常用函数"><a href="#读写锁的常用函数" class="headerlink" title="读写锁的常用函数"></a>读写锁的常用函数</h4><ul>
<li><code>pthread_rwlock_init</code></li>
<li><code>pthread_rwlock_destory</code></li>
<li><code>pthread_rwlock_wrlock</code></li>
<li><code>pthread_rwlock_rdock</code></li>
<li><code>pthread_rwlock_trywrlock</code></li>
<li><code>pthread_rwlock_tryrdlock</code></li>
<li><code>pthread_rwlock_unlock</code></li>
<li>以上的几个函数成功返回 <code>0</code> 失败返回可以通过 <code>strerror()</code> 判断</li>
<li>锁的类型如下:<ul>
<li><code>pthread_rwlock_t</code> 类型,用于定义一个读写锁变量</li>
<li><code>pthread_rwlock_t rwlock</code></li>
</ul>
</li>
<li>读写锁在读的线程多的时候效率会高于互斥锁</li>
</ul>
<h5 id="pthread-rwlock-init函数"><a href="#pthread-rwlock-init函数" class="headerlink" title="pthread_rwlock_init函数"></a>pthread_rwlock_init函数</h5><ul>
<li>作用: 初始化读写锁</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数参考 <code>pthread_lock_init</code></li>
</ul>
<h5 id="pthread-rwlock-destory函数"><a href="#pthread-rwlock-destory函数" class="headerlink" title="pthread_rwlock_destory函数"></a>pthread_rwlock_destory函数</h5><ul>
<li>作用: 销毁读写锁</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure></li>
<li>注意其他函数基本可以参考互斥锁的相关的 <code>API</code></li>
<li>注意三句话即可:<ul>
<li>读共享,写独占</li>
<li>写锁优先级高</li>
<li>全局只有一把读写锁</li>
</ul>
</li>
<li>读写锁的 <code>demo</code> 演示:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 读锁</span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">1</span>;</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock; <span class="comment">// 表示全局的读写锁</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">read_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---------------read %d , tid = %lu , counter = %d \n&quot;</span> , i , pthread_self() , counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">write_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">        t = counter;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---------------write %d , tid = %lu , t = %d , counter = %d \n&quot;</span> , i , pthread_self() , t ,  ++counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化 </span></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i ++)&#123;</span><br><span class="line">        ret = pthread_create(&amp;tid[i] , <span class="literal">NULL</span> , write_handler , (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create write thread failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">3</span> ; j &lt; <span class="number">8</span> ; j ++)&#123;</span><br><span class="line">        ret = pthread_create(&amp;tid[j] , <span class="literal">NULL</span> , read_handler , (<span class="type">void</span>*)j);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create read lock failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始循环回收</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">8</span> ; k ++)&#123;</span><br><span class="line">        pthread_join(tid[k] , <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>互斥锁: <code>pthread_mutex_t</code></li>
<li>读写锁: <code>pthread_rwlock_t</code></li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul>
<li>条件变量本身不是锁,但是它也可以造成线程阻塞,通常情况下与互斥锁配合使用,给多线程提供一个会合的场所</li>
</ul>
<h4 id="主要的应用函数"><a href="#主要的应用函数" class="headerlink" title="主要的应用函数"></a>主要的应用函数</h4><ul>
<li><code>pthread_cond_init</code></li>
<li><code>pthread_cond_destroy</code> </li>
<li><code>pthread_cond_wait</code>(相当于条件满足)</li>
<li><code>pthread_cond_timewait</code>(等待条件满足相当于<code>try</code>锁)</li>
<li><code>pthread_cond_signal</code>(表示条件满足进行通知)</li>
<li><code>pthread_cond_broadcast</code>(表示通知的时候使用广播模式)</li>
<li>以上六个函数的返回值都是成功返回 <code>0</code> , 失败直接返回错误号</li>
<li>常用类型:<ul>
<li><code>pthread_cond_t</code> 类型,用于定义条件变量</li>
<li><code>pthread_cond_t cond</code></li>
</ul>
</li>
</ul>
<h5 id="pthread-cond-init函数"><a href="#pthread-cond-init函数" class="headerlink" title="pthread_cond_init函数"></a>pthread_cond_init函数</h5><ul>
<li>作用: 初始化一个条件变量</li>
<li>注意条件判断</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure></li>
<li>参数和返回值不用多说,此时可以说一下后面的静态初始化方式,其实就是利用宏定义来初始化这一个锁,基本上和 <code>pthread_mutex_init</code> 和 <code>pthread_rwlock_init</code> 类似</li>
</ul>
<h5 id="pthread-cond-wait函数"><a href="#pthread-cond-wait函数" class="headerlink" title="pthread_cond_wait函数"></a>pthread_cond_wait函数</h5><ul>
<li>作用:<ol>
<li>阻塞等待条件变量 <code>cond</code> 满足</li>
<li>释放已经掌握的互斥锁(解锁互斥量),相当于<code>pthread_mutex_unlock</code>(注意 <code>1</code> 和 <code>2</code> 是一个原子操作)</li>
<li>当被唤醒,<code>pthread_cond_wait</code>函数返回的时候,解除阻塞并且重新申请互斥锁(<code>pthread_mutex_lock</code>)</li>
</ol>
</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">           <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>pthread_cond_wait</code>工作原理:<br><img src="/img/image%20copy%204.png" alt="alt text"></li>
</ul>
<h4 id="条件变量的生产者消费者模型"><a href="#条件变量的生产者消费者模型" class="headerlink" title="条件变量的生产者消费者模型"></a>条件变量的生产者消费者模型</h4><ul>
<li>生产者消费者模型图如下:<br><img src="/img/image%20copy%205.png" alt="alt text"></li>
<li>公共操作:<ul>
<li>首先定义锁 <code>pthread_mutex_t lock</code></li>
<li>初始化锁 <code>pthread_mutex_init(&amp;lock , NULL)</code></li>
</ul>
</li>
<li>消费者:<ul>
<li>加锁(尝试获取数据): <code>pthread_mutex_lock(&amp;lock)</code></li>
<li>条件是否满足,不满足阻塞等待: <code>pthread_cond_wait(&amp;cond , &amp;lock)</code></li>
<li>访问共享数据</li>
<li>释放锁<code>pthread_mutex_unlock(&amp;lock)</code>,并且循环上述操作</li>
</ul>
</li>
<li>生产者:<ul>
<li>生产数据</li>
<li>尝试获取锁(加锁): <code>pthread_mutex_lock(&amp;lock)</code></li>
<li>将数据存放到公共区域</li>
<li>解锁 <code>pthread_mutex_unlock(&amp;lock)</code></li>
<li>唤醒消费者,满足条件: <code>pthread_cond_signal(&amp;cond)</code> 或者 <code>pthread_cond_broadcast(cond)</code></li>
<li>循环生产后续数据</li>
</ul>
</li>
<li>消费者生产者模型代码实现:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Msg;  <span class="comment">// 共享数据相当于链表</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex; <span class="comment">// 互斥锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;  <span class="comment">// 条件变量</span></span><br><span class="line">Msg* pub_msg; <span class="comment">// 表示公共的数据</span></span><br><span class="line"><span class="type">int</span> i;  <span class="comment">// 表示消息的编号</span></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 1. 首先尝试获取数据,加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 2. 判断条件变量是否满足</span></span><br><span class="line">        <span class="keyword">while</span>(pub_msg -&gt; next == <span class="literal">NULL</span>)&#123;  <span class="comment">// 注意条件判断,如果公共数据区存在数据的,那么就可以直接取出数据</span></span><br><span class="line">            pthread_cond_wait(&amp;cond , &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 访问共享数据,此时已经加锁了</span></span><br><span class="line">        <span class="comment">// 利用头删法消费数据</span></span><br><span class="line">        Msg* temp = pub_msg -&gt; next;</span><br><span class="line">        pub_msg -&gt; next = temp -&gt; next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者获取: Message-%d \n&quot;</span> , temp -&gt; num);</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="comment">// 4. 释放锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 1. 首先生产数据</span></span><br><span class="line">        Msg* node = (Msg*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(Msg));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        node -&gt; num = i;</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="comment">// 2. 尝试加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 3. 把数据放入到公共区域</span></span><br><span class="line">        node -&gt; next = pub_msg -&gt; next;</span><br><span class="line">        pub_msg -&gt; next = node;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者生产: Message-%d \n&quot;</span> , node -&gt; num);</span><br><span class="line">        <span class="comment">// 4. 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 5. 唤醒消费者</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    pthread_mutex_init(&amp;mutex , <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond , <span class="literal">NULL</span>);</span><br><span class="line">    pub_msg = (Msg*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(Msg));</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">pthread_t</span> consumer_tid , producer_tid;</span><br><span class="line">    ret = pthread_create(&amp;consumer_tid , <span class="literal">NULL</span> , consumer_handler , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create consumer failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;producer_tid , <span class="literal">NULL</span> , producer_handler , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create producer failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回收</span></span><br><span class="line">    pthread_join(consumer_tid , <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(producer_tid , <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多个消费者使用while做"><a href="#多个消费者使用while做" class="headerlink" title="多个消费者使用while做"></a>多个消费者使用while做</h4><ul>
<li>分析一下多个消费者消费时候的流程: 当某一个线程被唤醒的时候,由与使用的都是同样一个 <code>cond</code> 所以都会被唤醒,所以如果被唤醒之后即可结束(使用<code>if</code>)判断条件的情况下,这一个线程就会立刻阻塞到 <code>lock</code> 的位置导致缺少对于公共数据是否为空减少判断导致出错</li>
<li>改进代码如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Msg;  <span class="comment">// 共享数据相当于链表</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex; <span class="comment">// 互斥锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;  <span class="comment">// 条件变量</span></span><br><span class="line">Msg* pub_msg; <span class="comment">// 表示公共的数据</span></span><br><span class="line"><span class="type">int</span> i;  <span class="comment">// 表示消息的编号</span></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 1. 首先尝试获取数据,加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 2. 判断条件变量是否满足</span></span><br><span class="line">        <span class="keyword">while</span>(pub_msg -&gt; next == <span class="literal">NULL</span>)&#123;  <span class="comment">// 注意条件判断,如果公共数据区存在数据的,那么就可以直接取出数据</span></span><br><span class="line">            pthread_cond_wait(&amp;cond , &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 访问共享数据,此时已经加锁了</span></span><br><span class="line">        <span class="comment">// 利用头删法消费数据</span></span><br><span class="line">        Msg* temp = pub_msg -&gt; next;</span><br><span class="line">        pub_msg -&gt; next = temp -&gt; next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者:%d 获取: Message-%d \n&quot;</span> , v + <span class="number">1</span>, temp -&gt; num);</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="comment">// 4. 释放锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 1. 首先生产数据</span></span><br><span class="line">        Msg* node = (Msg*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(Msg));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        node -&gt; num = i;</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="comment">// 2. 尝试加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 3. 把数据放入到公共区域</span></span><br><span class="line">        node -&gt; next = pub_msg -&gt; next;</span><br><span class="line">        pub_msg -&gt; next = node;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者生产: Message-%d \n&quot;</span> , node -&gt; num);</span><br><span class="line">        <span class="comment">// 4. 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 5. 唤醒消费者</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    pthread_mutex_init(&amp;mutex , <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond , <span class="literal">NULL</span>);</span><br><span class="line">    pub_msg = (Msg*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(Msg));</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">pthread_t</span>  producer_tid;</span><br><span class="line">    <span class="type">pthread_t</span> consumer_tid[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">2</span> ; j ++)&#123;</span><br><span class="line">        ret = pthread_create(&amp;consumer_tid[j] , <span class="literal">NULL</span> , consumer_handler , (<span class="type">void</span>*)j);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create consumer failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = pthread_create(&amp;producer_tid , <span class="literal">NULL</span> , producer_handler , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create producer failed: %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回收</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">2</span> ; j ++)&#123;</span><br><span class="line">        pthread_join(consumer_tid[j] , <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(producer_tid , <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="条件变量-signal注意事项"><a href="#条件变量-signal注意事项" class="headerlink" title="条件变量 signal注意事项"></a>条件变量 signal注意事项</h4><ul>
<li><code>pthread_cond_signal()</code>: 唤醒阻塞在条件变量上的(至少)一个线程</li>
<li><code>pthread_cond_broadcast()</code>: 唤醒阻塞在条件变量上的所有线程</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>相当于初始化值为 <code>N</code> 的互斥量,可以当成锁看待(这样允许有<code>N</code>个线程同时操作共享变量,提高了执行效率)(<code>N</code> 表示可以同时执行对于共享变量操作的线程个数)</li>
</ul>
<h4 id="主要应用函数"><a href="#主要应用函数" class="headerlink" title="主要应用函数"></a>主要应用函数</h4><ul>
<li><code>sem_init</code></li>
<li><code>sem_destroy</code> </li>
<li><code>sem_wait</code></li>
<li><code>sem_trywait</code>(相当于<code>pthread_mutex_trylock</code>)</li>
<li><code>sem_timedwait</code></li>
<li><code>sem_post</code></li>
<li>以上函数的返回值都是成功返回 <code>0</code>,失败返回 <code>-1</code>,同时设置<code>error</code>(注意没有<code>pthread</code>前缀)</li>
<li>使用的信号量类型:<ul>
<li><code>sem_t</code>类型: 本质仍然是结构体,但是应用期间可以看成简单函数,忽略实现细节(类似于文件描述符)</li>
<li><code>sem_t sem</code> 规定信号量<code>sem</code>不可以 <code>&lt; 0</code></li>
<li>头文件: <code>&lt;semaphore.h&gt;</code></li>
</ul>
</li>
</ul>
<h5 id="信号量操作函数"><a href="#信号量操作函数" class="headerlink" title="信号量操作函数"></a>信号量操作函数</h5><ul>
<li><code>sem_wait</code>:<ul>
<li>信号量大于<code>0</code>,则信号量<code>--</code></li>
<li>信号量等于<code>0</code>,则造成信号阻塞</li>
<li>对应于<code>pthread_mutex_lock</code></li>
</ul>
</li>
<li><code>sem_post</code>:<ul>
<li>将信号量<code>++</code>,同时唤醒阻塞在信号量上面的线程(类比<code>pthread_mutex_unlock</code>)</li>
</ul>
</li>
<li>但是,由于<code>sem_t</code>的实现对于用户隐藏,所以所谓的操作<code>++</code>或者<code>--</code>都是只可以通过函数实现,不可以直接通过<code>++</code>,<code>--</code>符号</li>
<li><strong>信号量的初始值决定了占用信号量的线程个数</strong></li>
<li>信号量: 可以应用于线程或者进程</li>
</ul>
<h5 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a>sem_init函数</h5><ul>
<li>作用: 初始化信号量</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数:<ul>
<li><code>sem</code> 信号量</li>
<li><code>pshared</code> <code>0</code> 表示线程之间同步,<code>1</code>表示进程之间同步</li>
<li><code>value</code> 就是表示 信号量的<code>N</code></li>
</ul>
</li>
</ul>
<h5 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h5><ul>
<li><code>sem_timedwait</code>: 指定阻塞时间(尝试时间)</li>
<li>函数原型如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *<span class="keyword">restrict</span> sem,</span></span><br><span class="line"><span class="params">                         <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abs_timeout)</span>;</span><br></pre></td></tr></table></figure></li>
<li>注意第二个参数: <code>abs_timeout</code> 就是指的绝对时间相当于 <code>1970.01.01</code></li>
</ul>
<h4 id="利用信号量实现生产者消费者模型"><a href="#利用信号量实现生产者消费者模型" class="headerlink" title="利用信号量实现生产者消费者模型"></a>利用信号量实现生产者消费者模型</h4><ul>
<li>利用信号量实现生产者消费者模型:<br><img src="/img/image%20copy%206.png" alt="alt text"></li>
<li>注意实现方式中可以把<code>sem_wait</code>当成对于信号量的<code>--</code>操作,<code>sem_post</code>看成<code>++</code>操作</li>
<li>代码实现如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM  5 <span class="comment">// 表示队列的最大长度</span></span></span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[NUM]; <span class="comment">// 表示队列</span></span><br><span class="line"><span class="type">sem_t</span> star_num;  <span class="comment">// 表示 物品的数量</span></span><br><span class="line"><span class="type">sem_t</span> blank_num; <span class="comment">// 表示空格的数量</span></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 表示开始下标</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 1. 首先利用 star_num 锁住</span></span><br><span class="line">        sem_wait(&amp;star_num);</span><br><span class="line">        <span class="comment">// 2. 消费元素</span></span><br><span class="line">        <span class="type">int</span> target = <span class="built_in">queue</span>[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-----consumer: %d \n&quot;</span> , target);</span><br><span class="line">        <span class="built_in">queue</span>[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 3. 唤醒生产者</span></span><br><span class="line">        sem_post(&amp;blank_num);</span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM;</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 1. 首先利用blank_num锁住</span></span><br><span class="line">        sem_wait(&amp;blank_num);</span><br><span class="line">        <span class="built_in">queue</span>[i] = rand() % <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-----producer: %d \n&quot;</span> , <span class="built_in">queue</span>[i]);</span><br><span class="line">        <span class="comment">// 2. 表示唤醒消费者</span></span><br><span class="line">        sem_post(&amp;star_num);</span><br><span class="line">        i = (i + <span class="number">1</span>) % NUM;</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; NUM ; i ++)&#123;</span><br><span class="line">        <span class="built_in">queue</span>[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sem_init(&amp;star_num , <span class="number">0</span> , <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;blank_num , <span class="number">0</span> , NUM);</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="type">pthread_t</span> consumer_tid , producer_tid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_create(&amp;consumer_tid , <span class="literal">NULL</span> , consumer_handler , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create consumer failed : %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;producer_tid , <span class="literal">NULL</span> , producer_handler , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span> , <span class="string">&quot;create producer failed : %s \n&quot;</span> , strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收</span></span><br><span class="line">    pthread_join(consumer_tid , <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(producer_tid , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    sem_destroy(&amp;star_num);</span><br><span class="line">    sem_destroy(&amp;blank_num);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xzwsloser.github.io">xzw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xzwsloser.github.io/2024/08/29/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">https://xzwsloser.github.io/2024/08/29/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xzwsloser.github.io" target="_blank">xzw の 的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">多线程编程</a></div><div class="post_share"><div class="social-share" data-image="https://img0.baidu.com/it/u=2423843250,176201309&amp;fm=253&amp;fmt=auto?w=500&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/08/27/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="进程编程"><img class="cover" src="https://img2.baidu.com/it/u=2477205961,1650218332&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">进程编程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xzw</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xzwsloser"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xzwsloser" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/3088655042@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">线程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">Linux内核线程实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E9%9D%9E%E5%85%B1%E4%BA%AB"><span class="toc-number">1.1.2.</span> <span class="toc-text">线程的共享和非共享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.2.</span> <span class="toc-text">线程控制原语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-self%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">pthread_self函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-create%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">pthread_create函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%88%9B%E5%BB%BA%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">循环创建子线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%85%B1%E4%BA%AB"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">线程和共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-exit%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">pthread_exit函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-join%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">pthread_join函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-cancel%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">pthread_cancel函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-detach%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">pthread_detach函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.6.</span> <span class="toc-text">进程控制原语和线程控制原语的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">线程属性设置分离线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BB%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">设置线程的分离状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E9%9D%9E%E5%88%86%E7%A6%BB%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">分离状态以及非分离状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">线程的使用注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.4.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.4.1.</span> <span class="toc-text">利用互斥锁进行线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F-mutex"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">互斥量(mutex)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#pthread-mutex-init%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.1.1.1.</span> <span class="toc-text">pthread_mutex_init函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pthread-mutex-destory%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.1.1.2.</span> <span class="toc-text">pthread_mutex_destory函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pthread-mutex-lock%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.1.1.3.</span> <span class="toc-text">pthread_mutex_lock函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#pthread-mutex-unlock%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.1.1.4.</span> <span class="toc-text">pthread_mutex_unlock函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.4.3.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">读写锁特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">读写锁的常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-rwlock-init%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.2.1.</span> <span class="toc-text">pthread_rwlock_init函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-rwlock-destory%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.2.2.</span> <span class="toc-text">pthread_rwlock_destory函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">主要的应用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-cond-init%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.1.1.</span> <span class="toc-text">pthread_cond_init函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pthread-cond-wait%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.1.2.</span> <span class="toc-text">pthread_cond_wait函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">条件变量的生产者消费者模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E4%BD%BF%E7%94%A8while%E5%81%9A"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">多个消费者使用while做</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-signal%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">条件变量 signal注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">主要应用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.5.1.1.</span> <span class="toc-text">信号量操作函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sem-init%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.5.1.2.</span> <span class="toc-text">sem_init函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.5.1.3.</span> <span class="toc-text">其他函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">利用信号量实现生产者消费者模型</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/29/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="多线程编程"><img src="https://img0.baidu.com/it/u=2423843250,176201309&amp;fm=253&amp;fmt=auto?w=500&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程编程"/></a><div class="content"><a class="title" href="/2024/08/29/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="多线程编程">多线程编程</a><time datetime="2024-08-29T15:44:15.621Z" title="发表于 2024-08-29 23:44:15">2024-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/27/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="进程编程"><img src="https://img2.baidu.com/it/u=2477205961,1650218332&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程编程"/></a><div class="content"><a class="title" href="/2024/08/27/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="进程编程">进程编程</a><time datetime="2024-08-27T14:46:45.866Z" title="发表于 2024-08-27 22:46:45">2024-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/25/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/" title="文件IO编程"><img src="https://img1.baidu.com/it/u=706797935,3702699894&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件IO编程"/></a><div class="content"><a class="title" href="/2024/08/25/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/" title="文件IO编程">文件IO编程</a><time datetime="2024-08-25T08:00:02.497Z" title="发表于 2024-08-25 16:00:02">2024-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/24/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%B7%A5%E5%85%B7%E9%93%BE/" title="编译,调试工具链"><img src="https://img1.baidu.com/it/u=2525231642,2721528165&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=1082" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="编译,调试工具链"/></a><div class="content"><a class="title" href="/2024/08/24/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%B7%A5%E5%85%B7%E9%93%BE/" title="编译,调试工具链">编译,调试工具链</a><time datetime="2024-08-24T08:37:40.678Z" title="发表于 2024-08-24 16:37:40">2024-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/24/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%9B%9E%E9%A1%BE/" title="Linux基础"><img src="https://img2.baidu.com/it/u=1854076240,1399178116&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=888" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux基础"/></a><div class="content"><a class="title" href="/2024/08/24/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%9B%9E%E9%A1%BE/" title="Linux基础">Linux基础</a><time datetime="2024-08-24T08:37:40.664Z" title="发表于 2024-08-24 16:37:40">2024-08-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By xzw</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>