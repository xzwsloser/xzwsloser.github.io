<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>进程编程 | xzw の 的个人博客</title><meta name="author" content="xzw"><meta name="copyright" content="xzw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程进程和程序以及CPU相关 进程与程序: 程序: 死的,只会占用磁盘空间(相当于剧本) 进程: 活的,运行起来的程序,占用内存,cpu等系统资源(相当于戏剧)   同一个程序可以加载成不同的进程 并发与并行: 并发: 在操作系统中,一个时间段中有多个进程都处于已经启动运行到运行完毕之间的状态,但是任意一个时间节点都只有一个程序在执行(单CPU同时执行多个任务)   并行: 表示多 CPU 同时执">
<meta property="og:type" content="article">
<meta property="og:title" content="进程编程">
<meta property="og:url" content="https://xzwsloser.github.io/2024/08/27/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="xzw の 的个人博客">
<meta property="og:description" content="进程进程和程序以及CPU相关 进程与程序: 程序: 死的,只会占用磁盘空间(相当于剧本) 进程: 活的,运行起来的程序,占用内存,cpu等系统资源(相当于戏剧)   同一个程序可以加载成不同的进程 并发与并行: 并发: 在操作系统中,一个时间段中有多个进程都处于已经启动运行到运行完毕之间的状态,但是任意一个时间节点都只有一个程序在执行(单CPU同时执行多个任务)   并行: 表示多 CPU 同时执">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=2477205961,1650218332&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500">
<meta property="article:published_time" content="2024-08-27T14:46:45.866Z">
<meta property="article:modified_time" content="2024-08-27T14:49:38.682Z">
<meta property="article:author" content="xzw">
<meta property="article:tag" content="进程编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=2477205961,1650218332&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500"><link rel="shortcut icon" href="/img/touxiang.webp"><link rel="canonical" href="https://xzwsloser.github.io/2024/08/27/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进程编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-27 22:49:38'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="xzw の 的个人博客"><img class="site-icon" src="/img/touxiang.webp"/><span class="site-name">xzw の 的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">进程编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-27T14:46:45.866Z" title="发表于 2024-08-27 22:46:45">2024-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-27T14:49:38.682Z" title="更新于 2024-08-27 22:49:38">2024-08-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/">C++ 后台开发</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">Linux系统编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="进程编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程和程序以及CPU相关"><a href="#进程和程序以及CPU相关" class="headerlink" title="进程和程序以及CPU相关"></a>进程和程序以及CPU相关</h2><ul>
<li>进程与程序:<ul>
<li>程序: 死的,只会占用磁盘空间(相当于剧本)</li>
<li>进程: 活的,运行起来的程序,占用内存,<code>cpu</code>等系统资源(相当于戏剧)</li>
</ul>
</li>
<li>同一个程序可以加载成不同的进程</li>
<li>并发与并行:<ul>
<li>并发:<ul>
<li>在操作系统中,一个时间段中有多个进程都处于已经启动运行到运行完毕之间的状态,但是任意一个时间节点都只有一个程序在执行(单<code>CPU</code>同时执行多个任务)</li>
</ul>
</li>
<li>并行:<ul>
<li>表示多 <code>CPU</code> 同时执行多个任务</li>
</ul>
</li>
</ul>
</li>
<li>通过时钟中断来控制进程的调度</li>
<li><code>CPU</code> 的工作机制:</li>
<li>注意一个寄存器的大小就是<code>4096B</code> 也就是 <code>4K</code></li>
<li><code>CPU</code> 与 <code>MMU(虚拟内存映射单元)</code><br><img src="/img/Screenshot_20240825_172310_tv.danmaku.bilibilihd.jpg" alt="alt text"></li>
</ul>
<h3 id="虚拟内存和物理内存的映射关系"><a href="#虚拟内存和物理内存的映射关系" class="headerlink" title="虚拟内存和物理内存的映射关系"></a>虚拟内存和物理内存的映射关系</h3><ul>
<li>注意程序不占用资源(只会占用磁盘空间)</li>
<li><code>CPU</code>一般会被内存分级,把用户空间映射到<code>3</code> 级,把内核空间映射成 <code>0</code>级,所以从用户空间到内存空间的映射时间消耗比较长</li>
<li>虚拟内存映射如系:<br><img src="/img/image-1.png" alt="alt text"></li>
<li><code>MMU</code> 的大小为 <code>4KB</code></li>
</ul>
<h3 id="PCB进程控制块"><a href="#PCB进程控制块" class="headerlink" title="PCB进程控制块"></a>PCB进程控制块</h3><ul>
<li><code>PCB</code>进程控制块是一个结构体,存储在 <code>/usr/src/linux-headers-6.8.0-40/include/linux /sched.h</code> 中 <code>struct task_struct</code></li>
<li>重点成员如下:<ul>
<li>进程 <code>id</code></li>
<li>进程的状态,就绪,运行,挂起(表示暂时停止(比如执行了 <code>sleep</code> 函数)),停止<br><img src="/img/Screenshot_20240825_175453_tv.danmaku.bilibilihd.jpg" alt="alt text"></li>
<li>进程切换时需要保存和恢复的一些<code>CPU</code>寄存器</li>
<li>描述虚拟地址空间的信息</li>
<li>占用终端的信息</li>
<li>当前的工作目录</li>
<li><code>umask</code>掩码</li>
<li>文件描述描述符号表</li>
<li>和信号相关的信息</li>
<li>用户<code>id</code>和组<code>id</code></li>
<li>会话(<code>Session</code>)和进程组</li>
<li>进程可以使用的资源上限(<code>Resource limit</code>)</li>
</ul>
</li>
</ul>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul>
<li><code>LD_LIBRARY_LIB</code> 动态链接器的寻找目录</li>
<li><code>PATH</code> 可执行程序的路径</li>
<li><code>SHELL</code> 查看当前使用的 <code>shell</code> 解析器</li>
<li><code>TERM</code> 查看当前使用的终端</li>
<li><code>HOME</code> 表示家目录</li>
<li><code>env</code> 查看所有环境变量(环境变量存放在用户空间和内核空间之间,这里还存放着<code>main</code>函数的参数)</li>
</ul>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="fork函数原理"><a href="#fork函数原理" class="headerlink" title="fork函数原理"></a>fork函数原理</h2><ul>
<li>作用: 创建一个子进程</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li>返回值:<ul>
<li>如果成功的话,在父进程中返回子进程的<code>PID</code>,并且在子进程中返回 <code>0</code>(表示子进程创建成功)</li>
<li>如果创建失败就会返回 <code>-1</code></li>
</ul>
</li>
<li><code>fork</code>相当于赋值,<code>fork</code>之后,子进程和父进程基本一样<br><img src="/img/image-2.png" alt="alt text"></li>
<li><code>fork</code>的演示<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fork1 ...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fork2 ...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fork3 ...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fork4 ...\n&quot;</span>);</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error!!!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child is created ... \n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my child pid is %d \n&quot;</span> , pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fork1 ... \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fork2 ... \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fork3 ... \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fork4 ... \n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>执行结果如下:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">before fork1 ...</span><br><span class="line">before fork2 ...</span><br><span class="line">before fork3 ...</span><br><span class="line">before fork4 ...</span><br><span class="line">my child pid is 16048 </span><br><span class="line">after fork1 ... </span><br><span class="line">after fork2 ... </span><br><span class="line">after fork3 ... </span><br><span class="line">after fork4 ... </span><br><span class="line">child is created ... </span><br><span class="line">after fork1 ... </span><br><span class="line">after fork2 ... </span><br><span class="line">after fork3 ... </span><br><span class="line">after fork4 ... </span><br></pre></td></tr></table></figure></li>
<li>可见,子进程的代码和父进程一致,但是<code>fork</code>之前的代码没有机会执行,<code>fork</code>之后的代码有机会执行,所以就会执行两次后面的操作,并且子进程和父进程的的执行相互独立</li>
</ul>
<h2 id="getpid-和-getppid"><a href="#getpid-和-getppid" class="headerlink" title="getpid 和 getppid"></a>getpid 和 getppid</h2><ul>
<li><code>getpid</code> 用于获取当前进程自己的 <code>pid</code></li>
<li><code>getppid</code> 用于获取当前进程的父进程的 <code>pid</code></li>
<li>演示 <code>demo</code>:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fork1 ...\n&quot;</span>);</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error!!!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child is created ... \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child , my pid is %d \n&quot;</span> , getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my father&#x27;s pid is %d \n&quot;</span> , getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;my child pid is %d \n&quot;</span> , pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the father , my pid is %d \n&quot;</span> , getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;and my father&#x27;s pid is %d \n&quot;</span> , getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fork1 ... \n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>父进程的父进程就是 <code>bash</code></li>
</ul>
<h2 id="循环创建子进程"><a href="#循环创建子进程" class="headerlink" title="循环创建子进程"></a>循环创建子进程</h2><ul>
<li>如果利用如下代码循环创建多个子进程:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环创建 n 个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 表示子进程</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是第 %d 个子进程,我的pid为: %d  \n&quot;</span>, i + <span class="number">1</span> , getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>但是最后结果创建了 <code>7</code> 个子进程,这是由于 <code>fork</code>之后,之后的循环代码,子进程仍然会继续调用余下的代码,调用图如下:<br><img src="/img/image-3.png" alt="alt text"></li>
<li>可以让父进程执行外之后退出,并且不再创建子进程了,所以演示代码如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环创建 n 个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 表示子进程</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是第 %d 个子进程,我的pid为: %d  \n&quot;</span>, i + <span class="number">1</span> , getpid());</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 注意需要退出,此时子进程就需要退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>但是可能出现如下问题:<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是第 2 个子进程,我的pid为: 38367  </span><br><span class="line">我是第 1 个子进程,我的pid为: 38366  </span><br><span class="line">我是第 3 个子进程,我的pid为: 38368  </span><br><span class="line">我是第 5 个子进程,我的pid为: 38370  </span><br><span class="line">我是第 4 个子进程,我的pid为: 38369  </span><br></pre></td></tr></table></figure></li>
<li>这是由于虽然每一个子进程被 <code>fork</code> 出来的顺序是按照顺序的,但是他们都会抢占 <code>CPU</code> 的执行权,所以首先抢占到 <code>CPU</code> 执行的进程就会执行打印的代码</li>
<li>也可以使用 <code>sleep</code> 函数完成礼让的作用:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环创建 n 个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the parent!!! \n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the %d th child \n&quot;</span>,i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a>进程共享</h2><ul>
<li>刚刚 <code>fork</code> 之后,父子进程的资源如下:<ul>
<li>父子进程相同之处: 全局变量,<code>data</code>,<code>.text</code>(代码段),栈,堆区,环境变量,用户<code>ID</code>,宿主目录,进程工作目录,信号处理方式都相同</li>
<li>父子进程不同之处: 进程<code>ID</code> <code>fork</code>返回值 父进程 <code>ID</code> 进程运行时间 闹钟(定时器) 未决信号集</li>
</ul>
</li>
<li>但是并不是子进程完全赋值父进程的用户空间,父子进程之间遵循着读时共享,写时复制的原则,这样设计,无论子进程和父进程执行各种操作都可以节约空间</li>
<li>测试<code>demo</code>如下:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> var = <span class="number">100</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        var = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child , my pid is %d , my father&#x27;s pid is %d , var is %d  \n&quot;</span> , getpid() , getppid() , var);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        var = <span class="number">300</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the father , my pid is % d , var is %d \n&quot;</span> , getpid() , var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="父子进程共享"><a href="#父子进程共享" class="headerlink" title="父子进程共享"></a>父子进程共享</h3><ul>
<li>父子进程共享:<ul>
<li>文件描述符</li>
<li><code>mmap</code>映射区域</li>
</ul>
</li>
<li>共享遵循读时共享,写时复制(所以并不是完全共享全局变量)</li>
<li>但是父子进程的执行时机依赖于父进程的调度算法</li>
</ul>
<h2 id="父子进程-gdb-调试"><a href="#父子进程-gdb-调试" class="headerlink" title="父子进程 gdb 调试"></a>父子进程 gdb 调试</h2><ul>
<li>主要是两个命令:<ul>
<li><code>set follow-fork-mode child</code> 命令设置 <code>gdb</code> 在 <code>fork</code> 之后跟踪子进程</li>
<li><code>set follow-fork-mode parent</code> 设置跟踪父进程</li>
</ul>
</li>
<li>注意一定需要在 <code>fork</code> 函数之前执行</li>
</ul>
<h2 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec 函数族"></a>exec 函数族</h2><ul>
<li>作用: 让子进程和父进程执行程序</li>
<li><code>exec</code>函数族中的函数如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/*, (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/*, (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>exec</code>函数族执行的过程:<ul>
<li>当父进程在 <code>fork</code> 之后调用了 <code>exec</code> 函数,那么子进程在调用到 <code>exec</code> 函数之后,就不会在接着执行接下来的代码了,而是执行 <code>exec</code> 指定的任务</li>
</ul>
</li>
<li>但是执行任务的子进程还没有改变<br><img src="/img/image-4.png" alt="alt text"></li>
</ul>
<h3 id="execl-和-execlp-函数"><a href="#execl-和-execlp-函数" class="headerlink" title="execl 和 execlp 函数"></a>execl 和 execlp 函数</h3><h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h4><ul>
<li>作用: 加载一个进程,借助<code>PATH</code>环境变量</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                       <span class="comment">/*, (char *) NULL */</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li>该函数一般用于调用系统函数,比如 <code>ls</code> <code>date</code> <code>cp</code> <code>cat</code> 等命令</li>
<li>参数:<ul>
<li><code>file</code> 可执行程序文件名称</li>
<li><code>arg</code> 表示选项</li>
</ul>
</li>
<li>注意最后一定需要加上一个 <code>NULL</code> 作为一个哨兵,表示结束</li>
<li>但是注意参数从 <code>arg0</code> 开始计算,并且 <code>arg0</code> 就是命令名称本身</li>
<li>一个小的细节(<code>ls -lh</code>) 表示显示单位并且使用长列表的方式显示文件列表</li>
<li>调用 <code>execlp</code> 方法执行系统的函数方式如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 子进程使用 exelp 调用系统函数</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork child failed !!! \n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child \n&quot;</span>);</span><br><span class="line">        <span class="comment">// execlp(&quot;ls&quot; , &quot;ls&quot; , &quot;-l&quot; , &quot;-h&quot; , NULL);</span></span><br><span class="line">        execlp(<span class="string">&quot;date&quot;</span> , <span class="string">&quot;date&quot;</span> , <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child finished !!! \n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the parent !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="execl-函数"><a href="#execl-函数" class="headerlink" title="execl 函数"></a>execl 函数</h4><ul>
<li>作用: 可以执行第三方的程序,比如自己写的程序,之后的参数基本和 <code>execlp</code> 一致</li>
<li>设置知道系统函数的路径之后,可以调用系统函数</li>
<li>演示<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child !!! \n&quot;</span>);</span><br><span class="line">        <span class="comment">// execl(&quot;./create_loop_fork&quot; , &quot;./create_loop_fork&quot;,NULL);</span></span><br><span class="line">        <span class="comment">// 执行系统的命令</span></span><br><span class="line">        execl(<span class="string">&quot;/usr/bin/ls&quot;</span> , <span class="string">&quot;ls&quot;</span> , <span class="string">&quot;-l&quot;</span> , <span class="string">&quot;-h&quot;</span> , <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child finshed !!! \n&quot;</span>);  <span class="comment">// 没有了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the father !!! \n&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个小的案例: 把 <code>ps</code> 的内容输入到文件中,注意利用 <code>dup2</code> 进行重定向输出<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 利用 ps 命令把进程信息写入到文件中</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed !!!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 1. 首先创建文件</span></span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;./out&quot;</span> , O_CREAT | O_RDWR | O_TRUNC , <span class="number">0644</span>);</span><br><span class="line">        <span class="comment">// 2. 重定向</span></span><br><span class="line">        <span class="type">int</span> new_fd = dup2(fd , STDOUT_FILENO);  <span class="comment">// 表示把标准输出重定向到 fd 中</span></span><br><span class="line">        <span class="comment">// 3. 调用 ps 命令</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span> , <span class="string">&quot;ps&quot;</span> , <span class="string">&quot;aux&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the father !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><ul>
<li><code>execvp</code> 函数: 作用基本和 <code>execl</code> 基本一样,唯一的不同就是第二个参数是一个数组不是可变参数</li>
<li><code>exec</code> 函数族的特点:<ul>
<li>只有错误才会返回 <code>-1</code></li>
</ul>
</li>
<li>所以一般就在 <code>exec</code> 后面调用 <code>perror</code> 函数和 <code>exit</code>函数</li>
<li><code>exec</code> 函数各种后缀的含义:<ul>
<li><code>l(list)</code>: 命令行参数列表</li>
<li><code>p(path)</code>: 搜索变量的时候使用 <code>path</code>变量</li>
<li><code>v(vector)</code>: 使用命令行参数数组</li>
<li><code>e(environment)</code>: 使用环境变量数组,不使用进程原有的环境变量,设置新加载程序运行时的环境变量</li>
</ul>
</li>
<li>六种函数之间的关系,注意只有<code>exece</code>是系统调用,其他的都是封装了<code>exece</code>:<br><img src="/img/Screenshot_20240825_215832_tv.danmaku.bilibilihd.jpg" alt="alt text"></li>
</ul>
<h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><ul>
<li>孤儿进程: 父进程先于子进程结束,则子进程成为孤儿进程,子进程的父进程成为 <code>init</code> 进程,成为<code>init</code> 进程领养孤儿进程(相当于进程孤儿院)</li>
<li><code>ps ajx</code> 用于查看子进程的父进程</li>
<li>代码演示如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 演示孤儿进程</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am the child , my pid is %d , ppid is %d \n&quot;</span> , getpid() , getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the father , my pid is %d \n&quot;</span> , getpid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul>
<li>僵尸进程: 进程停止,父进程尚未回收,子进程残留资源(<code>PCB</code>)存放在内核中,变成僵尸进程(<code>Zombie</code>)进程,理论上来说,基本所有进程都会经历僵尸进程的状态,其实回收的就是<code>PCB</code>,其中会记录子进程结束的原因</li>
<li>处理僵尸进程的方式: 将它的父进程杀死,让子进程变成孤儿进程从而被回收</li>
<li>代码演示如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child , my pid is %d , my ppid is %d \n&quot;</span> , getpid() ,getppid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am the father , my pid is %d , my son&#x27;s pid is %d \n&quot;</span> , getpid() , pid);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait 函数"></a>wait 函数</h3><ul>
<li>作用: 用于回收子进程</li>
<li>原理: 可以根据子进程残留的 <code>PCB</code> 进程块获取到子进程的信息,从而回收子进程</li>
<li>父进程调用<code>wait</code>函数可以回收子进程终止信息,该函数有三个状态:<ul>
<li>阻塞等待子进程退出</li>
<li>回收子进程残留资源</li>
<li>获取子进程结束状态(退出原因)</li>
</ul>
</li>
<li>头文件: <code>&lt;sys/wait.h&gt;</code></li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *_Nullable wstatus)</span>;</span><br><span class="line">     <span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *_Nullable wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> <span class="title function_">waitid</span><span class="params">(<span class="type">idtype_t</span> idtype, <span class="type">id_t</span> id, <span class="type">siginfo_t</span> *infop, <span class="type">int</span> options)</span>;</span><br><span class="line">                     <span class="comment">/* This is the glibc and POSIX interface; see</span></span><br><span class="line"><span class="comment">                        NOTES for information on the raw system call. */</span></span><br></pre></td></tr></table></figure></li>
<li>参数:<ul>
<li><code>status</code> 表示子进程的状态,可以传入一个整形参数的地址用于接受即可(并且可以利用宏函数来判断子进程退出原因)</li>
</ul>
</li>
<li>返回值: 回收失败就会返回 <code>-1</code></li>
<li>演示<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> wpid;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child , my pid is %d , my parent&#x27;s pid is %d \n&quot;</span>,getpid(),getppid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        wpid = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;failed to resouce the child !!! \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wid = %d \n&quot;</span> , wpid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;successfully resouce the child !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="获取子进程退出值和异常终止信号"><a href="#获取子进程退出值和异常终止信号" class="headerlink" title="获取子进程退出值和异常终止信号"></a>获取子进程退出值和异常终止信号</h4><ul>
<li>一般来说都是由于信号才会时的进程终止,比如 <code>kill -l</code> 可以查看所有信号量</li>
<li>利用各种宏定义函数可以判断子进程突出原因:<ul>
<li><code>WIFEXITED</code> 返回<code>true</code> 表示子进程正常退出,如果使用<code>exit</code>函数默认返回 <code>1</code></li>
<li><code>WEXITSTATUS</code> 上面一个返回 <code>true</code> 的情况下,返回子进程退出的返回值(<code>return</code>)</li>
<li><code>WIFSIGNALED</code> 如果子进程被信号终止,就会返回 <code>true</code></li>
<li><code>WTERMSIG</code> 返回子进程被终止的信号</li>
<li><code>WIFSTOPPED</code> 判断进程是否暂停</li>
<li><code>WSTOPIG</code> 获取暂停子进程的信号</li>
<li><code>WIFCOUNTINE</code> 获取让子进程继续执行的信号</li>
</ul>
</li>
<li>演示<code>demo</code>:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> wpid;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);  <span class="comment">// 如果调用 exit函数默认返回 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child , my pid is %d , my parent&#x27;s pid is %d \n&quot;</span>,getpid(),getppid());</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        wpid = wait(&amp;status);  <span class="comment">// 如果子进程没有终止,父进程就会阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;failed to resouce the child !!! \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))&#123;  <span class="comment">// 正常退出</span></span><br><span class="line">            <span class="type">int</span> res = WEXITSTATUS(status); <span class="comment">// 获取退出状态</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child return the number: %d \n&quot;</span> , res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(status)) &#123;  <span class="comment">// 表示异常终止,说明子进程被信号终止</span></span><br><span class="line">            <span class="comment">// 查看信号</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child killed with signale: %d \n&quot;</span> , WTERMSIG(status));</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wid = %d \n&quot;</span> , wpid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;successfully resouce the child !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h3><ul>
<li>作用: 回收子进程</li>
<li>头文件:<ul>
<li><code>&lt;sys/wait.h&gt;</code></li>
</ul>
</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *_Nullable wstatus, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数:<ul>
<li><code>pid</code> 需要回收子进程的 <code>pid</code>:<ul>
<li><code>&gt;0</code> 指定<code>ID</code>的子进程</li>
<li><code>-1</code> 回收任意子进程(相当于<code>wait</code>)</li>
<li><code>0</code>  回收和当前调用<code>waitpid</code>一个组的所有子进程</li>
<li><code>&lt;-1</code> 回收指定进程组里面的任意子进程(组号等于绝对值)</li>
</ul>
</li>
<li><code>wstatus</code> 记录子进程的状态</li>
<li><code>options</code> 可以设置函数的属性,比如可以设置函数的属性为非阻塞的形式</li>
</ul>
</li>
<li>返回值:<ul>
<li>成功回收返回子进程 <code>id</code></li>
<li>函数调用的时候,指定了<code>WNOHANG</code>,并且没有子进程结束</li>
<li>失败返回 <code>-1</code> 和 <code>errorno</code></li>
</ul>
</li>
<li>细节: 无论是<code>wait</code>还是<code>waitpid</code>调用,只是可以回收一个子进程</li>
<li>演示<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid,wait_pid;</span><br><span class="line">    <span class="type">int</span> target;</span><br><span class="line">    <span class="type">int</span> i  ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span> &amp;&amp; pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            target = pid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am the child , my pid is %d \n&quot;</span> , getpid());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始回收</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 1. 回收任意的 pid</span></span><br><span class="line">        <span class="comment">// wait_pid = waitpid(-1 , NULL , WNOHANG); // 表示不会阻塞</span></span><br><span class="line">        <span class="comment">// 此时没有回收的进程成为孤儿进程被回收</span></span><br><span class="line">        <span class="comment">// 2. 指定 pide</span></span><br><span class="line">        wait_pid = waitpid(target , <span class="literal">NULL</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait_pid = %d \n&quot;</span> , wait_pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent , my pid is %d \n&quot;</span> , pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the %d th child , my pid is %d \n&quot;</span> , i + <span class="number">1</span> , getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>进程编程的时候,一定需要注意父子进程进行变量共享的时候,遵循读是共享,写时复制的原则</li>
<li>总结: <ul>
<li><code>wait</code> 和 <code>waitpid</code> 的区别: <code>wait</code>只可以阻塞的等待并且不可以指定具体需要回收那一个子进程,<code>waitpid</code>可以指定是否阻塞并且需要回收那一个子进程</li>
<li>共同之处: 只可以回收一个子进程,不可以回收多个子进程</li>
</ul>
</li>
</ul>
<h3 id="利用-waitpid-回收多个子进程"><a href="#利用-waitpid-回收多个子进程" class="headerlink" title="利用 waitpid 回收多个子进程"></a>利用 waitpid 回收多个子进程</h3><ul>
<li>需要使用循环回收多个子进程</li>
<li>演示<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="comment">// 回收</span></span><br><span class="line">        <span class="comment">// 1. 阻塞的方式回收</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the father , I am gonna to resource my child \n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> wpid;</span><br><span class="line">        <span class="comment">// while((wpid = waitpid(-1 , NULL , 0)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;Successfully resource child, pid: %d \n&quot; , wpid);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 2. 非阻塞的方式回收</span></span><br><span class="line">        <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span> , <span class="literal">NULL</span> , WNOHANG)) != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid == <span class="number">0</span>)&#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Successfully resource child, pid: %d \n&quot;</span> , wpid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the %d th child , my pid is %d \n&quot;</span> , i + <span class="number">1</span> , getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>相当于: <code>waitpid(-1 , &amp;status , 0) == wait(&amp;status)</code></li>
</ul>
<h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><ul>
<li>要求父进程<code>fork</code> <code>3</code> 个子进程,三个子进程一个调用 <code>ps</code> 命令,一个调用自定义程序 <code>1</code>(正常) , 另外一个调用自定义程序 <code>2</code>(发生段错误),父进程使用 <code>waitpid</code> 对于子进程进行回收</li>
<li>演示<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始调用</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the %d child , my pid is %d \n&quot;</span> , i + <span class="number">1</span> , getpid());</span><br><span class="line">        <span class="comment">// 调用 ps 命令</span></span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;./out&quot;</span> , O_CREAT | O_TRUNC | O_RDWR , <span class="number">0644</span>);</span><br><span class="line">        <span class="comment">// 重定向</span></span><br><span class="line">        <span class="type">int</span> new_fd = dup2(fd , STDOUT_FILENO);</span><br><span class="line">        <span class="comment">// ps 命令</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span> , <span class="string">&quot;ps&quot;</span> , <span class="string">&quot;aux&quot;</span> , <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 无法关闭文件, 利用父进程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用正常的程序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the %d child , my pid is %d \n&quot;</span> , i + <span class="number">1</span> , getpid());</span><br><span class="line">        execlp(<span class="string">&quot;./test_demo1&quot;</span> , <span class="string">&quot;./test_demo1&quot;</span> ,<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用异常程序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the %d child , my pid is %d \n&quot;</span> , i + <span class="number">1</span> , getpid());</span><br><span class="line">        execlp(<span class="string">&quot;./test_demo2&quot;</span> , <span class="string">&quot;./test_demo2&quot;</span> , <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the father !!! \n&quot;</span>);</span><br><span class="line">        <span class="comment">// 开始进行回收</span></span><br><span class="line">        <span class="type">int</span> wpid;</span><br><span class="line">        <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span> , &amp;status , <span class="number">0</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 首先判断状态</span></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">                    <span class="comment">// 表示正常退出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;返回值为: %d \n&quot;</span> , WEXITSTATUS(status));</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;异常终止,终止信号为: %d \n&quot;</span> , WTERMSIG(status));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Successfully resource the child whose pid is %d \n&quot;</span> , wpid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h1><ul>
<li>由于父子进程之间基本隔离,所以如果需要进行数据的相互交换,那就需要进行进程之间的通信,进程之间通信(<code>IPC</code>)</li>
<li>原理:<ul>
<li>父子进程公用一个内核空间(当然这是物理上的),其实父子进程之间的桥梁就是内核中的一个缓冲区(默认大小为<code>4096B(4K)</code>)</li>
</ul>
</li>
<li>进程中通信的方式(最常用的四种):<ul>
<li>管道(使用最简单)</li>
<li>信号(开销最小)</li>
<li>共享映射区(无血缘关系)</li>
<li>本地套接字(最稳定)</li>
</ul>
</li>
</ul>
<h2 id="匿名管道-pipe"><a href="#匿名管道-pipe" class="headerlink" title="匿名管道(pipe)"></a>匿名管道(pipe)</h2><h3 id="管道的性质"><a href="#管道的性质" class="headerlink" title="管道的性质"></a>管道的性质</h3><ul>
<li>管道是一种最基本的<code>IPC</code>机制,作用于有血缘关系的进程之间,完成数据的传递,调用 <code>pipe</code> 系统函数就可以创建一个管道,有如下性质:<ul>
<li>本质就是一个伪文件(处理普通文件,目录,软链接等,其他的都是伪文件,不会占用磁盘空间)</li>
<li>有两个文件描述符引用,一个表示读端,另外一个表示写端</li>
<li>规定数据从管道的写端流入管道,从读端流出管道</li>
</ul>
</li>
<li>管道的原理: 管道实际上是内核使用循环队列的形式实现出来的,借助内核缓冲区<code>(4K)</code>实现</li>
<li>管道的局限性:<ul>
<li>数据不可以自己写入,自己读取</li>
<li>管道中数据不可以重复读取,一旦读走,管道中就不再存在了</li>
<li>采用(双向)半双工通信方式,数据只可以在单方向上流动</li>
<li>只能在有公共祖先的进程之间使用管道</li>
</ul>
</li>
<li>单工通信: 比如遥控器</li>
<li>半双工通信: 比如对讲机,每一次只有一个端可以传递信息</li>
<li>全双工通信: 相当与打电话(<code>WebSocket</code>)</li>
</ul>
<h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><ul>
<li>作用: 创建一个管道,并且打开管道</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数:<ul>
<li><code>pipefd[0]</code>  表示读端</li>
<li><code>pipedf[1]</code>  表示写端</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功返回 <code>0</code>  失败返回 <code>-1</code></li>
</ul>
</li>
<li>相当于传递着一个数组之后,就可以把着一个数组中填充读端和写端,父子进程都可以获取到管道的两端</li>
<li>最后一定需要注意关闭读端或者写端,调用 <code>close</code> 函数,一个写的时候,必须关闭另外一个端</li>
<li>注意利用 <code>read</code> 读取之后,可以使用 <code>write</code>写入到 <code>STDOUT</code> 中</li>
<li>管道演示<code>demo</code>:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 1. 创建管道</span></span><br><span class="line">    <span class="type">int</span> res = pipe(pipefd);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];  <span class="comment">// 这样可以节约空间</span></span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;create pipe failed!!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 利用 fork调用子进程</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork the child failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 表示子进程</span></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);  <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="type">int</span> ret = read(pipefd[<span class="number">0</span>] , buf , <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read from pipe failed !!! \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        write(STDOUT_FILENO , buf , ret);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 表示父进程</span></span><br><span class="line">        <span class="comment">// 向管道中写入数据</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);  <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="type">char</span>* str = <span class="string">&quot;hello pipe\n&quot;</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>] , str , <span class="built_in">strlen</span>(str));</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><ul>
<li>读管道:<ul>
<li>如果管道中有数据,<code>read</code>返回时机读到的字节数</li>
<li>如果管道中没有数据:<ul>
<li>管道写端被全部关闭,<code>read</code>返回<code>0</code>(就像读到了文件结尾)</li>
<li>管道写端没有被全部关闭,<code>read</code>阻塞等待(不久的将来可能会有数据到达,此时会让出<code>cpu</code>)</li>
</ul>
</li>
</ul>
</li>
<li>写管道:<ul>
<li>如果管道的读端被完全关闭,进程异常终止(也有可能捕捉<code>SIGPIPE</code>信号,使得进程不终止)</li>
<li>管道读端没有全部关闭:<ul>
<li>管道已满,<code>write</code>阻塞</li>
<li>管道没有满,<code>write</code>将数据写入,并且返回时机写入的字节数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul>
<li>实现父子之间进程的通信,实现<code>ls | wc -l</code>,假设父进程实现<code>ls</code>,子进程实现<code>wc</code></li>
<li>注意几个细节:<ul>
<li><code>ls</code> 默认把信息输入到 <code>stdout</code> 所以需要让 <code>stdout</code> 指向 <code>pipefd[1]</code></li>
<li><code>wc</code> 默认从 <code>stdin</code> 中读取, 所以需要让 <code>stdin</code>指向 <code>pipefd[0]</code></li>
</ul>
</li>
<li>实现<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;create pipe failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork child failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 实现 wc</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 重定向</span></span><br><span class="line">        <span class="type">int</span> ret = dup2(pipefd[<span class="number">0</span>] , STDIN_FILENO);  <span class="comment">// wc -l 从输入中读取,其实就是从pipe[0]中读取</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;dup2 failed !!! \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        execlp(<span class="string">&quot;wc&quot;</span> , <span class="string">&quot;wc&quot;</span> , <span class="string">&quot;-l&quot;</span> , <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* target;</span><br><span class="line">        <span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            target = <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target = argv[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现 ls 命令</span></span><br><span class="line">        <span class="comment">// 1. 重定向</span></span><br><span class="line">        <span class="type">int</span> newfd = dup2(pipefd[<span class="number">1</span>] , STDOUT_FILENO);</span><br><span class="line">        <span class="keyword">if</span>(newfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;dup2 error !&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 调用</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span> , <span class="string">&quot;ls&quot;</span> , target , <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="兄弟进程之间的通信"><a href="#兄弟进程之间的通信" class="headerlink" title="兄弟进程之间的通信"></a>兄弟进程之间的通信</h3><ul>
<li>利用兄弟之间进程通信实现 <code>ls | wc -l</code></li>
<li>注意对于一个管道,一定需要形成一个消息传递链,如下代码中如果没有在父进程中加上关闭写端和读端的操作,就会造成如下结果:<br><img src="/img/image-5.png" alt="alt text"></li>
<li>没有达到管道的回路状态</li>
<li>正确的代码如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现兄弟之间进程的通信</span></span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;create pipe failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">2</span> ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个进程</span></span><br><span class="line">        <span class="comment">// 实现 ls</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am going to do ls , my pid is %d \n&quot;</span>, getpid());</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> newfd = dup2(pipefd[<span class="number">1</span>] , STDOUT_FILENO);</span><br><span class="line">        <span class="keyword">if</span>(newfd == <span class="number">-1</span> ) &#123;</span><br><span class="line">            perror(<span class="string">&quot;dup2 failed!!! \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 开始执行操作</span></span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span> , <span class="string">&quot;ls&quot;</span> , <span class="literal">NULL</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 第二个进程</span></span><br><span class="line">        <span class="comment">// 实现 wc 操作</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am going to do wc , my pid is %d \n&quot;</span>, getpid());</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> newfd = dup2(pipefd[<span class="number">0</span>] , STDIN_FILENO);</span><br><span class="line">        <span class="keyword">if</span>(newfd == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;dup2 failed !!! \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始执行操作</span></span><br><span class="line">        execlp(<span class="string">&quot;wc&quot;</span> , <span class="string">&quot;wc&quot;</span> , <span class="string">&quot;-l&quot;</span> , <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// 父亲进程</span></span><br><span class="line">        <span class="comment">// 进行进程的回收</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the parent , going to resource my child !!! \n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> wpid;</span><br><span class="line">        <span class="comment">// sleep(10);</span></span><br><span class="line">        <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span> , <span class="literal">NULL</span> , <span class="number">0</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wpid != <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Successfully resource my child whose pid is %d \n&quot;</span> , wpid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多个读写端操作和管道缓冲区的大小设置"><a href="#多个读写端操作和管道缓冲区的大小设置" class="headerlink" title="多个读写端操作和管道缓冲区的大小设置"></a>多个读写端操作和管道缓冲区的大小设置</h3><ul>
<li>结论: 一个<code>pipe</code>可以有多个写端,一个读端,但是最好不用这样用,这样难以进行定点之间信息的传递,但是需要经可能避免这一种情况,并且无法控制消息的顺序</li>
<li>使用 <code>ulimit -a</code> 可以查询缓冲区的大小,管道的缓冲区大小为 <code>4K</code></li>
<li>还可以使用 <code>fpathconf</code> 查询管道大小,函数原型如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>name</code> 可以传入多种宏定义,用于判断查询类型</li>
</ul>
<h3 id="管道的优缺点"><a href="#管道的优缺点" class="headerlink" title="管道的优缺点"></a>管道的优缺点</h3><ul>
<li>优点: 简单,相比于信号,套接字实现进程间通信,简单很多</li>
<li>缺点:<ul>
<li>只可以单向通信,双向通信需要建立两个管道</li>
<li>之可以用于父子,兄弟进程(有共同祖先)间通信,该问题之后使用 <code>fifo</code> 有名管道解决</li>
</ul>
</li>
</ul>
<h2 id="具名管道-fifo"><a href="#具名管道-fifo" class="headerlink" title="具名管道(fifo)"></a>具名管道(fifo)</h2><ul>
<li>基本原理和<code>pipe</code>差不多: 都是利用在内核空间建立缓冲区的方式实现管道的,不同之处在于<code>fifo</code>给管道起了名字</li>
</ul>
<h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><ul>
<li>创建方式:<ul>
<li>命令: <code>mkfifo 管道名</code></li>
<li>库函数: <code>mkfifo</code></li>
</ul>
</li>
<li><code>mkfifo</code>函数原型如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure></li>
<li>头文件:<ul>
<li><code>&lt;sys/types.h&gt;</code></li>
<li><code>&lt;sys/stat.h&gt;</code></li>
</ul>
</li>
<li>参数:<ul>
<li><code>pathname</code> 路径</li>
<li><code>mode</code> 类似于 <code>open</code> 选项(权限值)</li>
</ul>
</li>
<li>返回值:<ul>
<li>成功返回 <code>0</code>  失败范围 <code>-1</code></li>
</ul>
</li>
<li>创建管道的<code>fifo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">int</span> ret = mkfifo(<span class="string">&quot;./myfifo&quot;</span> , <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;create fifo failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="利用fifo实现非血缘关系进程之间通信"><a href="#利用fifo实现非血缘关系进程之间通信" class="headerlink" title="利用fifo实现非血缘关系进程之间通信"></a>利用fifo实现非血缘关系进程之间通信</h3><ul>
<li>把 <code>fifo</code> 看成一个文件:<ul>
<li>写端: 打开文件(只是写入方式) , 利用 <code>write</code> 写入数据</li>
<li>读端: 读取文件(只是读方式) , 利用 <code>read</code> 读文件</li>
</ul>
</li>
<li>可以实现一个写端多个读端和多个读端一个写端</li>
<li>读的方式如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 演示从管道中读取数据</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;请输入管道名称 \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">1</span>] , O_RDONLY);</span><br><span class="line">    <span class="comment">// 不断读取数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((n = read(fd , buf , <span class="number">1024</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read from fifo failed !!! \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(STDOUT_FILENO , buf , n);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>写的方式如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 向管道中写入数据</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;请输入管道名称 !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开</span></span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">1</span>] , O_WRONLY);</span><br><span class="line">    <span class="comment">// 开始写入数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf , <span class="string">&quot;hello fifo %d \n&quot;</span> , i);</span><br><span class="line">        <span class="type">int</span> ret = write(fd , buf , <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;write into fifo failed !!! \n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i ++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="文件用于进程之间的通信"><a href="#文件用于进程之间的通信" class="headerlink" title="文件用于进程之间的通信"></a>文件用于进程之间的通信</h3><ul>
<li>使用文件也可以完成<code>IPC</code>,理论依据就是<code>fork</code>之后,父子共享文件描述符,所以父子进程之前,可以通过同一个文件描述符号找到同一个文件，一个进行读操作,另外一个进行写操作即可</li>
<li>对于不同的进程,由于不同的进程的 <code>PCB</code> 不同,所以肯能文件描述符号不同,但是不同的文件描述符号还是指向了同一个文件,所以还是可以对于一个文件进行读操作,另外一个文件进行写操作,所以没有血缘关系的进程也可以打开同一个文件进行通信</li>
</ul>
<h2 id="存储映射-I-O"><a href="#存储映射-I-O" class="headerlink" title="存储映射 I&#x2F;O"></a>存储映射 I&#x2F;O</h2><ul>
<li>存储映射: 使得一个磁盘与存储空间爱你的一个缓冲区向映射(其实就是磁盘和内存的映射),并且进入内存之后就可以得到地址,利用地址就可以使用指针进行 <code>IO</code> 操作,而不依赖与 <code>read</code> 和 <code>write</code> 函数对于文件进行操作</li>
<li>映射方式如下:<br><img src="/img/Screenshot_20240826_161245_tv.danmaku.bilibilihd.jpg" alt="alt text"></li>
</ul>
<h3 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h3><ul>
<li>作用: 完成存储映射</li>
<li>头文件: <code>&lt;sys/mmap.h&gt;</code></li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> addr[.length], <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数: <ul>
<li><code>addr</code>  指定映射区域的首地址(通常可以传递 <code>NULL</code> 表示让系统自动分配)</li>
<li><code>length</code> 表示共享内存映射区域的大小 (<code>&lt;=</code> 文件大小)</li>
<li><code>prot</code> 表示共享内存区域的读写属性:<ul>
<li><code>PROT_READ</code>  只读</li>
<li><code>PROT_WRITE</code> 只写</li>
<li><code>PROT_READ | PROT_WRITE</code> 读写</li>
</ul>
</li>
<li><code>flags</code> 标记共性属性(<code>MAP_SHARED</code> <code>MAP_PRIVATE</code>(对于内存的修改不会同步到磁盘))</li>
<li><code>fd</code>  用于创建共享内存映射区域的文件的文件描述符号</li>
<li><code>offset</code> 偏移位置(相当于磁盘中的文件)(必须是 <code>4K</code> 的整数倍)(<code>0</code> 表示映射文件的全部)</li>
</ul>
</li>
<li>返回值(泛型指针):<ul>
<li>成功: 成功创建的内存映射区域的首地址</li>
<li>失败: <code>MAP_FAILED</code> 就是 <code>(void*)(-1)</code> 并且设置 <code>errorno</code></li>
</ul>
</li>
</ul>
<h4 id="利用-mmap-建立映射区域"><a href="#利用-mmap-建立映射区域" class="headerlink" title="利用 mmap 建立映射区域"></a>利用 mmap 建立映射区域</h4><ul>
<li>注意使用 <code>munmap</code> 函数进行映射空间的释放</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> addr[.length], <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure></li>
<li>注意拓展文件的方式:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 利用 mmap 创建内存映射</span></span><br><span class="line">    <span class="comment">// 1. 首先获取文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;temp.txt&quot;</span> , O_CREAT | O_TRUNC | O_RDWR , <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;create file failed !!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 对于文件进行扩容操作</span></span><br><span class="line">    <span class="comment">// 2.1 第一种方式,使用 lseek</span></span><br><span class="line">    <span class="comment">// lseek(fd , 10 , SEEK_END);</span></span><br><span class="line">    <span class="comment">// write(fd , &quot;\0&quot; , 1);</span></span><br><span class="line">    <span class="comment">// 2.2 利用 ftranc 函数</span></span><br><span class="line">    ftruncate(fd , <span class="number">20</span>);  <span class="comment">// 扩容函数</span></span><br><span class="line">    <span class="comment">// 3. 获取文件大小</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd , <span class="number">0</span> , SEEK_END); <span class="comment">// 获取长度</span></span><br><span class="line">    <span class="comment">// 4. 调用 mmap 函数</span></span><br><span class="line">    <span class="type">char</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 相当于自动类型转换</span></span><br><span class="line">    p = mmap(<span class="literal">NULL</span>,len,  PROT_READ | PROT_WRITE , MAP_SHARED , fd , <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;mmap failed!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(p , <span class="string">&quot;hello mmap!!!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 5. 释放映射区域</span></span><br><span class="line">    <span class="type">int</span> ret = munmap(p , len);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;munmap failed !!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mmap使用注释事项"><a href="#mmap使用注释事项" class="headerlink" title="mmap使用注释事项"></a>mmap使用注释事项</h4><ul>
<li><p>用于创建映射区域的大小为 <code>0</code> , 实际指定非 <code>0</code> 大小创建映射区域,会出现 总线错误(或者偏移大于文件大小)</p>
</li>
<li><p>用于创建映射区的文件大小为 <code>0</code> , 实指定 <code>0</code> 大小创建映射区,出 无效参数错误</p>
</li>
<li><p>用于创建文件读写属性为只读,映射区域属性为读写(必须读写或者前者大于后者),出 无效参数错误</p>
</li>
<li><p>使用<code>ftruncate</code>扩展文件,需要向文件中写入数据,所以需要把文件的权限设置为可写</p>
</li>
<li><p>创建映射区域需要<code>read</code>权限(创建的时候需要从文件中的读出信息来建立映射区域),<code>mmap</code>的读写权限必须小于等于文件的 <code>open</code> 权限</p>
</li>
<li><p>文件描述符号<code>fd</code> 在创建文件映射区域完毕之后就可以关闭了,之后直接操作地址即可</p>
</li>
<li><p>‵offset‵ 必须是 <code>4096</code>的整数倍,和<code>MMU</code>相关,注意<code>MMU</code>映射的最小长度就是 <code>4K</code></p>
</li>
<li><p>对于申请的内存,不可以越界访问</p>
</li>
<li><p><code>mumap</code>释放的地址必须是<code>mmap</code>创建得到的地址,就是不可以改变指针的位置</p>
</li>
<li><p>一定需要检测<code>mmap</code> 操作是否成功</p>
</li>
<li><p>映射区域访问权限为<code>MAP_PRIVATE</code> 表示设置私有权限,就会导致在内存中对于文件的操作不会反映到磁盘上</p>
</li>
<li><p>设置<code>prot</code>权限为 <code>MAP_PRIVATE</code>的时候,只需要<code>open</code>的时候有读权限,用于创建映射区域就可以了,用于创建映射区域即可,原因就是不用同步到磁盘上</p>
</li>
<li><p><code>mmap</code> 函数的保险调用方式:</p>
<ul>
<li><code>open(O_RDWR)</code></li>
<li><code>mmap(NULL , 有效大小 , PROT_READ | PROT_WRITE , MAP_SHARED , fd , 0)</code></li>
</ul>
</li>
</ul>
<h4 id="mmap建立父子之间通信"><a href="#mmap建立父子之间通信" class="headerlink" title="mmap建立父子之间通信"></a>mmap建立父子之间通信</h4><ul>
<li>为了保证通信可行,所以 <code>flags</code> 需要设置为 <code>MPA_SHARED</code>(否则就会归父进程私有)</li>
<li>首先利用 <code>mmap</code> 建立映射区域,之后利用 <code>fork</code> 创建子线程</li>
<li>父子进程使用<code>mmap</code>进行通信:<ul>
<li>首先创建映射区域: <code>open</code>  <code>mmap</code>,指定权限为 <code>MAP_SHARED</code></li>
<li>创建子进程</li>
<li>一个进程读,一个进程写</li>
</ul>
</li>
<li>父子进程之间通信的方式如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;out&quot;</span> , O_CREAT | O_TRUNC | O_RDWR , <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;open file failed !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    ret = ftruncate(fd , <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;ftruncate failed !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取长度</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd , <span class="number">0</span> , SEEK_END);</span><br><span class="line">    <span class="comment">// 建立内存映射区域</span></span><br><span class="line">    <span class="type">char</span>* p = mmap(<span class="literal">NULL</span> , len , PROT_READ | PROT_WRITE , MAP_SHARED , fd , <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;mmap failed !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="built_in">strcpy</span>(p , <span class="string">&quot;hello father!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        write(STDOUT_FILENO , p , <span class="built_in">strlen</span>(p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    ret = munmap(p , len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;umap failed !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="mmap进行非血缘关系进程之间通信"><a href="#mmap进行非血缘关系进程之间通信" class="headerlink" title="mmap进行非血缘关系进程之间通信"></a>mmap进行非血缘关系进程之间通信</h4><ul>
<li><p>注意其实内存中的操作最终会被同步到磁盘,所以和利用文件进行通信类似,但是这一种方式基于内存,操作更快更加便捷</p>
</li>
<li><p>好处就是可以传递任意数据类型(包含结构体等信息)</p>
</li>
<li><p>注意可以使用 <code>memcpy</code> 作内存拷贝(注意不是拼接而是拷贝)</p>
</li>
<li><p>函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> dest[<span class="keyword">restrict</span> .n], <span class="type">const</span> <span class="type">void</span> src[<span class="keyword">restrict</span> .n],</span></span><br><span class="line"><span class="params">                    <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>写进程代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;<span class="number">18</span> , <span class="string">&quot;xiaoming&quot;</span> , <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;out&quot;</span> , O_CREAT | O_TRUNC | O_RDWR , <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;open file failed !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    ret = ftruncate(fd , <span class="keyword">sizeof</span>(stu));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;truncate file failed !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = lseek(fd , <span class="number">0</span> , SEEK_END);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span>* <span class="title">p</span> =</span> mmap(<span class="literal">NULL</span> , len , PROT_READ | PROT_WRITE , MAP_SHARED , fd , <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;mmap failed !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p , &amp;stu , <span class="keyword">sizeof</span>(stu));</span><br><span class="line">        stu.id ++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读进程如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;out&quot;</span> , O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;open file failed !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    <span class="type">int</span> len = lseek(fd , <span class="number">0</span> , SEEK_END);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span>* <span class="title">p</span> =</span> mmap(<span class="literal">NULL</span> , len , PROT_READ | PROT_WRITE , MAP_SHARED , fd , <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">        sys_exit(<span class="string">&quot;mmap failed !!! \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">// 开始读取文件</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id = %d , name = %s , age = %d \n&quot;</span> , p-&gt; id , p-&gt;name , p -&gt; age);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>支持一个读端多个写端,一个写端多个读端</p>
</li>
<li><p>没有血缘关系进程之间通信:</p>
<ul>
<li>两个进程同时打开同一个文件,创建映射区</li>
<li>指定<code>flag</code> 为<code>MAP_SHARED</code></li>
</ul>
</li>
<li><p>注意没有血缘关系的进程之间通信的两种方式比较:</p>
<ul>
<li><code>mmap</code> 可以多次读</li>
<li><code>fifo</code> 只可以一次读</li>
</ul>
</li>
</ul>
<h4 id="mmap匿名映射区"><a href="#mmap匿名映射区" class="headerlink" title="mmap匿名映射区"></a>mmap匿名映射区</h4><ul>
<li>删除用于创建映射区的文件删除之后仍然可以创建映射区,所以可以创建匿名映射区</li>
<li>此时<code>fd</code> 参数可以指定为 <code>-1</code></li>
<li>函数的使用方式:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmap(<span class="literal">NULL</span> , <span class="number">40</span> , PROT_READ|PROT_WRITE , MAP_SHARED | MAP_ANONYMOUS , <span class="number">-1</span> , <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
<li>但是无法完成非血缘关系进程之间的映射</li>
</ul>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul>
<li>信号的特点:<ul>
<li>简单</li>
<li>不可以携带大量信息</li>
<li>满足特定条件才可以发送信号</li>
</ul>
</li>
</ul>
<h3 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a>信号的机制</h3><ul>
<li>信号的特质:<ul>
<li>信号是软件层面的中断,一旦信号产生,无论程序执行到什么位置,必须停止运行,处理信号,处理结束,在继续执行后续指令</li>
</ul>
</li>
<li>所有信号都是由内核发送并且处理的</li>
</ul>
<h3 id="与信号相关的时间和状态"><a href="#与信号相关的时间和状态" class="headerlink" title="与信号相关的时间和状态"></a>与信号相关的时间和状态</h3><ul>
<li>产生信号:<ul>
<li>按键产生: <code>Ctrl + C</code> <code>Ctrl + Z</code></li>
<li>系统调用产生: <code>kill</code>  <code>raise</code></li>
<li>软件条件产生: 比如定时器 <code>alarm</code>(比如<code>sleep</code>)</li>
<li>硬件异常产生, 比如: 非法访问内存(段错误),除<code>0</code>,内存对齐错误</li>
<li>命令产生,比如<code>kill</code>命令</li>
</ul>
</li>
<li>递达(递送到达): 递达并且到达进程</li>
<li>未决： 产生和递归之间的状态,主要由于阻塞(屏蔽)导致着一个状态</li>
<li>信号的处理方式:<ul>
<li>执行默认动作</li>
<li>忽略</li>
<li>捕捉(调用用户处理函数)</li>
</ul>
</li>
<li><code>Linux</code>内核的进程控制块<code>PCB</code>是一个结构体,<code>task_struct</code> 除了包含进程<code>id</code>, 状态,工作目录,用户<code>id</code>,组<code>id</code>,文件描述符,还包含了信号相关的信息,主要指的就是阻塞信号集和未决信号集</li>
<li>阻塞信号集(信号屏蔽字): 将某些信号加入到集合中,对他们设置屏蔽,当屏蔽x信号之后,在受到该信号,该信号的处理将推后(接触屏蔽之后)</li>
<li>未决信号集:<ul>
<li>信号产生,未绝信号集中描述该信号的位立刻翻转为 <code>1</code>,表示信号处于未决状态,当信号被处理,对应的位立刻翻转为 <code>0</code>,这一个时刻往往比较短暂</li>
<li>信号产生之后,由于某些原因(主要是由于阻塞)不可以抵达,这一类信号的集合称之为未决信号集,在屏蔽接触之前,信号一直处于未决状态(屏蔽的时候产生)</li>
</ul>
</li>
<li>信号都是固定的,未决信号集和信号屏蔽字中都是存储着他各种信号状态(信号种类都是由操作系统规定的)</li>
<li>信号处理过程如下:<br><img src="/img/image-6.png" alt="alt text"></li>
</ul>
<h3 id="常见的信号和信号四要素"><a href="#常见的信号和信号四要素" class="headerlink" title="常见的信号和信号四要素"></a>常见的信号和信号四要素</h3><ul>
<li><p>利用 <code>kill -l</code> 查看各种信号</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX	</span><br></pre></td></tr></table></figure></li>
<li><p>信号四要素:</p>
<ul>
<li>编号</li>
<li>名称</li>
<li>事件</li>
<li>默认处理动作</li>
</ul>
</li>
<li><p>利用 <code>man 7 signal</code> 可以查看信号的各种特征</p>
</li>
<li><p><code>Linux</code>常见信号一览表:</p>
</li>
<li><p>常见的信号比如: <code>SIGHUP</code>  <code>SIGINT</code>  <code>SIGKILL</code> <code>SIGQUIT</code> <code>SIGBUS</code>(总线错误) <code>SIGPE</code> <code>SIGUSR1</code> <code>SIGSEGV</code> <code>SIGUSR2</code> <code>SIGPIPE</code> <code>SIGALRM</code> <code>SIGTERM</code> <code>SIGCHLD</code> <code>SIGSTOP</code><br><img src="/img/image-7.png" alt="alt text"></p>
</li>
<li><p>默认动作:</p>
<ul>
<li><code>Term</code>: 终止进程</li>
<li><code>lgn</code>: 忽略信号(默认就是对该信号忽略操作) </li>
<li><code>Core</code>: 终止进程,生成<code>Core</code>文件(查验进程死亡原因,用于<code>gdb</code>调试)</li>
<li><code>Stop</code>: 停止(暂停)进程</li>
<li><code>Cont</code>: 继续执行进程</li>
</ul>
</li>
<li><p>但是注意 <code>9)SIGKILL</code> 和 <code>19)SIGSTOP</code> 不允许忽略或者捕捉,甚至不可以设置未屏蔽</p>
</li>
<li><p>只有每一个信号对应的时间发生了,该信号才可以被递达,不可以乱发信号</p>
</li>
</ul>
<h3 id="kill函数与kill命令"><a href="#kill函数与kill命令" class="headerlink" title="kill函数与kill命令"></a>kill函数与kill命令</h3><h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><ul>
<li>利用 <code>kill</code> 命令产生信号: <code>kill -SIGKILL 进程号</code> 就是 <code>kill -信号号码 进程号</code></li>
</ul>
<h4 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h4><ul>
<li>作用: 向某一个进程发送信号</li>
<li>头文件: <code>&lt;signal.h&gt;</code></li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数:<ul>
<li><code>pid</code> 需要给那一个进程发送信号<ul>
<li><code>pid &gt; 0</code> 发送信号给默认的进程</li>
<li><code>pid = 0</code> 发送信号给调用 <code>kill</code> 函数进程属于同一个进程组的所有进程</li>
<li><code>pid &lt; -1</code> 取<code>pid</code>发送给对应的进程组(进程组号就是 <code>-pid</code>)</li>
<li><code>pid = -1</code> 发送给进程所有权限发送的系统中的所有进程</li>
</ul>
</li>
<li><code>sig</code> 信号编号(宏定义)</li>
</ul>
</li>
<li>返回值: <ul>
<li>成功返回 <code>0</code></li>
<li>失败返回 <code>-1</code> 设置 <code>errono</code></li>
</ul>
</li>
<li>普通用户的基本规则就是: 发送者的实际或者有效用户<code>ID</code> &#x3D;&#x3D; 接受者实际或者有效的用户<code>ID</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child , my pid is %d , my ppid is %d \n&quot;</span> , getpid() , getppid());</span><br><span class="line">        <span class="comment">// kill(getppid() , SIGSEGV);  // 表示段错误</span></span><br><span class="line">        <span class="comment">// kill(getppid() , SIGKILL)  表示强制杀死进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am child ! \n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the parent , my pid is %d \n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">// while(1)&#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;this is my code !!! \n&quot;);</span></span><br><span class="line">        <span class="comment">//     sleep(1);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 进程组 id 其实就是当前进程的id</span></span><br><span class="line">        <span class="comment">// kill(- getppid() , SIGKILL);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>循环创建进程并且杀死指定进程:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环创建5个子进程并且利用 kill 函数杀死任意一个进程</span></span><br><span class="line">    <span class="type">int</span> target;  <span class="comment">// 记录需要杀死的子进程假设就是 第三个</span></span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork failed !!!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span> &amp;&amp; i == <span class="number">2</span>)&#123;</span><br><span class="line">            target = pid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt;= <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the %d th child , my pid is %d \n&quot;</span>,i + <span class="number">1</span> , getpid());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> ret = kill(target , SIGKILL);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;kill failed !!!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d \n&quot;</span> , ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h3><ul>
<li>作用: 设置定时器(闹钟),指定<code>seconds</code>之后,内核会给当前进程发送<code>14)SIGALRM</code>信号,进程受到信号之后,默认动作终止,每一个进程都有且仅有唯一一个定时器</li>
<li>头文件: <code>&lt;unistd.h&gt;</code></li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数: 表示设置的秒数</li>
<li>返回值: <code>0</code> 或者剩余的秒数(重置定时器之前的剩余秒数),没有失败的情况</li>
<li>比如以下过程中: <code>alarm(5) -- 3 sec -- alarm(4) -- 5sec -- alarm(5) -- alarm(0)</code></li>
<li>此时 <code>alarm(4)</code> 返回 <code>5 - 3 = 2</code>  <code>alarm(5)</code> 由于上一次定时器超过时间返回 <code>0</code> <code>alarm(0)</code> 返回上一次定时器的剩余时间 <code>5</code></li>
<li><code>alarm(0)</code>  用于清除定时器</li>
<li>闹钟时间到的时候,就会向程序发送信号表示闹钟结束,会终止进程</li>
<li>可以使用 <code>time</code> 命令,程序运行的瓶颈在于<code>IO</code>,优化程序,首选优化 <code>IO</code></li>
<li>实际执行时间 &#x3D; 系统时间 + 用户时间 + 等待时间</li>
</ul>
<h3 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h3><ul>
<li>函数功能: 设置定时器,可以替代 <code>alarm</code>函数精度微秒可以设置定时周期</li>
<li>头文件: <code>&lt;sys/timer.h&gt;</code></li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *<span class="keyword">restrict</span> new_value,</span></span><br><span class="line"><span class="params">                     <span class="keyword">struct</span> itimerval *_Nullable <span class="keyword">restrict</span> old_value)</span>;</span><br></pre></td></tr></table></figure></li>
<li>参数: <ul>
<li><code>which</code>:<ul>
<li>自然定时: <code>ITIMER_REAL -&gt; 14) SLGLARM</code> 计算自然时间</li>
<li>虚拟空间计时(用户空间): <code>ITIMER_VIRTUAL -&gt; 26) SIGVTALRM</code> 只是计算进程占用 <code>CPU</code> 的时间</li>
<li>运行时计时(用户+内核) : <code>ITIMER_PROF -&gt; 27)SIGPROF</code> 只计算占用 <code>cpu</code> 和执行系统调用的时间</li>
</ul>
</li>
<li><code>new_value</code> 新的定时时间</li>
<li><code>old_value</code> 传出参数,表示剩余的时间,是一个传出参数</li>
</ul>
</li>
<li>返回值:<ul>
<li>成功返回 <code>0</code></li>
<li>失败返回 <code>-1</code> 设置 <code>errorno</code></li>
</ul>
</li>
<li><code>struct itimerval</code> 类型的定义如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* Interval for periodic timer */</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* Time until next expiration */</span></span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">           <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">           <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>it_interval</code> 用于设定两次定时任务之间的时间间隔</li>
<li><code>it_value</code> 定时的时长</li>
<li>演示<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 setitmer 完成定时任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">old_value</span>;</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">1</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 相当于设置 alarm(1) ,可以一次设置多个值</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;new_value , &amp;old_value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;old_value.it_interval.tv_sec = %ld \n&quot;</span> , old_value.it_interval.tv_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;old_value.iterval.tv_usec = %ld \n&quot;</span> , old_value.it_interval.tv_usec);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span> , i);</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>但是如果使用第一种模式,其实他会发送一个终止进程的停止闹钟信号,所以就像只是设置了一轮一样,注意两个定时器时间间隔和一个定时器的执行之间之间的区别</li>
</ul>
<h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><ul>
<li>阻塞信号集可以操作,未决信号集不可以操作但是通过阻塞信号集的方式操作未决信号集</li>
<li>作用: 设置自定义信号集,后面就是传入参数</li>
<li>信号集设置的函数如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br></pre></td></tr></table></figure></li>
<li>名称可以显示各个函数的作用,作用分别是:<ul>
<li>信号集设置为空</li>
<li>信号集填充</li>
<li>信号集添加某一个位</li>
<li>信号集删除某一个位</li>
<li>判断信号集中的位</li>
</ul>
</li>
<li>参数:<ul>
<li><code>set</code>  表示一个位图</li>
</ul>
</li>
</ul>
<h4 id="sigprocmask-函数"><a href="#sigprocmask-函数" class="headerlink" title="sigprocmask 函数"></a>sigprocmask 函数</h4><ul>
<li>作用: 用于屏蔽信号,解除信号也可以使用这一个函数,他的本质,读取或者修改进程的信号品屏蔽字(<code>PCB</code>中)</li>
<li>注意: 屏蔽信号,只是将信号延后执行(延后到接触屏蔽),并且忽略将信号丢处理</li>
<li>函数原型如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> <span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                                 <span class="type">sigset_t</span> *_Nullable <span class="keyword">restrict</span> oldset)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>参数解释</li>
<li><code>set</code>: 表示一个传入参数,是一个位图,<code>set</code>中位置为<code>1</code>,就表示当前进程屏蔽哪一个信号</li>
<li><code>oldset</code>: 传出参数,保存旧的信号屏蔽集(就的<code>mask</code>)</li>
<li><code>how</code>参数取值:  假设当前的信号屏蔽字为<code>mask</code><ul>
<li><code>SIG_BLOCK</code> 当<code>how</code>设置为这一个值的时候,<code>set</code>表示需要屏蔽的信号,相当于 <code>mask = mask | set</code></li>
<li><code>SIG_UNBLOCK</code> 当<code>how</code>设置为这一个值的时候,<code>set</code>表示需要解除屏蔽的信号,相当于<code>mask = mask &amp; ~set</code></li>
<li><code>SIG_SETMASK</code> 当<code>mask</code>设置为这一个值的时候,<code>set</code>用于替代与原始屏蔽和新的屏蔽集,相当于 <code>mask = set </code> ,调用<code>sigprocmask</code>解除了对于当前若干个信号的阻塞,则在<code>sigprocmask</code>返回之前,至少将其中一个信号递达</li>
</ul>
</li>
</ul>
<h4 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h4><ul>
<li><p>作用: 读取未决信号集</p>
</li>
<li><p>函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>参数:</p>
<ul>
<li><code>set</code> 表示一个传出参数</li>
</ul>
</li>
<li><p>实践方式: 首先利用 <code>sigemptyset</code> 等函数自定义信号集对于<code>set</code>进行设置,之后利用 <code>sigprocmask</code>函数操作信号即,注意<code>how</code>参数,利用<code>sigpending</code>查看未决信号集</p>
</li>
<li><p>信号集合函数演示如下:</p>
</li>
<li><p>注意信号一定需要产生之后,才可以被屏蔽,如果信号产生也就谈不上是否被屏蔽,屏蔽之后对应的位图中的位就会发生改变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_set</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">32</span> ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sigismember(<span class="built_in">set</span> , i))&#123;</span><br><span class="line">            <span class="comment">// 表示存在</span></span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span> , oldset;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span> , SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span> , SIGKILL);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span> , SIGSTOP);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span> , SIGQUIT);</span><br><span class="line">    <span class="comment">// 开始进行改变</span></span><br><span class="line">    ret = sigprocmask(SIG_BLOCK , &amp;<span class="built_in">set</span> , &amp;oldset);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;sigprocmask error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">sigset_t</span> pedset;</span><br><span class="line">    <span class="comment">// 注意发生信号才可以解析</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ret = sigpending(&amp;pedset);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            sys_err(<span class="string">&quot;sigpending failed !!! \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        print_set(&amp;pedset);</span><br><span class="line">        sleep(<span class="number">1</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h3><h4 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h4><ul>
<li>作用: 注册一个捕捉函数(并不是完成信号的捕捉)(这是信号递达之后的事情)</li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>注意函数指针的定义方式,这样定义就会使得,<code>sighandler_t</code>成为一个类型,这一个类型指向形如 <code>function&lt;void(int)&gt;</code> 的函数,当然可以使用 <code>function&lt;void(int)&gt;</code>进行包装</li>
<li>参数:<ul>
<li><code>signum</code> 表示信号</li>
<li><code>handler</code> 表示处理方式</li>
</ul>
</li>
<li>演示<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler_func</span><span class="params">(<span class="type">int</span> signal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;catch you !!! %d  \n&quot;</span> , signal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 演示捕捉进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        signal(SIGINT , handler_func);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h4><ul>
<li>实现捕捉函数的注册</li>
<li>函数原型如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="keyword">struct</span> sigaction *_Nullable <span class="keyword">restrict</span> act,</span></span><br><span class="line"><span class="params">                   <span class="keyword">struct</span> sigaction *_Nullable <span class="keyword">restrict</span> oldact)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>参数:<ul>
<li><code>signum</code>: 需要捕捉的信号</li>
<li><code>act</code>: 指定捕捉函数,<code>sa_mask sa_flags</code>等信息</li>
<li><code>oldact</code>: 传出参数表示之前的配置信息</li>
</ul>
</li>
<li>参数中的结构体如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">            <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>); <span class="comment">// 信号处理方式</span></span><br><span class="line">            <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">// 携带复杂结构体</span></span><br><span class="line">            <span class="type">sigset_t</span>   sa_mask; <span class="comment">// 作用于信号捕捉函数活动期间</span></span><br><span class="line">            <span class="type">int</span>        sa_flags;</span><br><span class="line">            <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></li>
<li>由于信号捕捉的优先级高于信号处理的优先级别,如果不设置<code>sa_mask</code> 变量,<code>PCB</code>中的<code>mask</code>从进程创建开始一直存在,所以如果在这一个进程执行的时候,由另外一个信号发送给这一个进程如果还是依赖于同样的<code>mask</code>就会导致相当的信号重复捕捉重复执行到时循环,所以引入<code>sa_mask</code>,这一个变量在信号处理的过程中替代<code>mask</code>从而防止这一种情况</li>
<li>绝大多情况下<code>sa_mask</code> 和 <code>sa_flags</code>都可以传递 <code>0</code> 作为参数</li>
<li>使用<code>demo</code>如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">catch_signal</span><span class="params">(<span class="type">int</span> signal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;catch you %d !!! \n&quot;</span> , signal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 利用 sigaction 函数进行信号的捕捉</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span> , <span class="title">oldact</span>;</span></span><br><span class="line">    act.sa_handler = catch_signal;</span><br><span class="line">    <span class="comment">// 注意清除的方式</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask); <span class="comment">// 相当于清空  sa_mask</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 开始注册</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = sigaction(SIGINT , &amp;act , &amp;oldact);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = sigaction(SIGQUIT , &amp;act , &amp;oldact);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction failed !!! \n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a>信号捕捉特性</h4><ul>
<li>进程正常运行的时候,默认的<code>PCB</code>中一个信号屏蔽字(<code>mask</code>),他决定了进程自动屏蔽那些信号,当注册了某个信号捕捉函数,捕捉到该信号之后,要调用该函数,而该函数有可能需要执行很长时间,在这一个期间所屏蔽的信号不会由<code>mask</code>来指定,而是由<code>sa_mask</code>指定,调用完信号处理函数就会恢复为 <code>mask</code></li>
<li><code>XXX</code> 信号捕捉函数执行期间,<code>XXX</code>信号自动屏蔽(<code>sa_flags = 0</code>)</li>
<li>阻塞的常规信号不支持排队,产生多次只会记录一次(但是后面32个实时信号支持排队)</li>
<li>如果需要在捕捉某一个信号的同时屏蔽另外一个信号可以考虑设置<code>sa_mask</code>的值来屏蔽另外一个信号</li>
</ul>
<h4 id="内核实现进程捕捉的过程"><a href="#内核实现进程捕捉的过程" class="headerlink" title="内核实现进程捕捉的过程"></a>内核实现进程捕捉的过程</h4><p><img src="/img/Screenshot_20240827_173928_tv.danmaku.bilibilihd.jpg" alt="alt text"></p>
<h3 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h3><ul>
<li><code>SIGCHLD</code>信号的产生条件:<ul>
<li>子进程终止的时候</li>
<li>子进程接收到<code>SIGSTOP</code>信号停止的时候</li>
<li>子进程处于停止状态,接收到<code>SIGCONT</code>之后唤醒</li>
</ul>
</li>
</ul>
<h4 id="使用-SIGCHLD-信号回收子进程"><a href="#使用-SIGCHLD-信号回收子进程" class="headerlink" title="使用 SIGCHLD 信号回收子进程"></a>使用 SIGCHLD 信号回收子进程</h4><ul>
<li>子进程结束之后,其父进程会受到<code>SIGCHLD</code>信号,该信号的默认处理动作就是忽略,可以捕捉该信号,在捕捉函数中完成进程状态的回收</li>
<li>如果使用如下代码,那么就会导致处理信号的时候,子进程发送的信号就会被屏蔽,导致子进程无法被回收,导致僵尸进程的产生<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler_child</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 回收子进程</span></span><br><span class="line">    <span class="type">int</span> wpid;</span><br><span class="line">    wpid = wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Successfully resource my child: %d \n&quot;</span> , wpid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 利用 SIGNCHLD 信号回收子进程</span></span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="comment">// 表示父进程,开始回收子进程</span></span><br><span class="line">        <span class="comment">// 回收</span></span><br><span class="line">        <span class="comment">// 首先注册</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = handler_child;</span><br><span class="line">        sigaction(SIGCHLD , &amp;act , <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am the parent , my pid is %d \n&quot;</span> , getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child ,my pid is %d , my ppid is %d \n&quot;</span> , getpid() , getppid());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>利用 <code>SIGCHLD</code> 进行的最佳实践如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义捕捉函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">catch_child</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wpid ,status;</span><br><span class="line">    <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span> , &amp;status , <span class="number">0</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Successfully resource child whose pid is %d and return_val is %d \n&quot;</span> , wpid , WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置 SIGCHLD 阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> sig;</span><br><span class="line">    sigemptyset(&amp;sig);</span><br><span class="line">    sigaddset(&amp;sig , SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK , &amp;sig , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">15</span> ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">15</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 首先进行注册</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = catch_child;</span><br><span class="line">        sigaction(SIGCHLD , &amp;act , <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 解除</span></span><br><span class="line">        <span class="type">sigset_t</span> new_sig;</span><br><span class="line">        sigemptyset(&amp;new_sig);</span><br><span class="line">        sigaddset(&amp;new_sig , SIGCHLD);</span><br><span class="line">        sigprocmask(SIG_UNBLOCK , &amp;new_sig , <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am parent , my pid is %d \n&quot;</span> , getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child , my pid is %d , my ppid is %d \n&quot;</span> , getpid() , getppid());</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>首先明确第一程序中出现的问题: 当父进程回收其他子进程的时候,此时另外的子进程发送 <code>SIGCHLD</code> 信号,此时这些信号就不会被捕捉到,所以这里采用循环捕获的方法进行捕获,从而使得多个子进程同时死亡的时候可以捕获</li>
<li>另外一个问题就是如果子进程在注册捕捉函数之前死亡,父进程就无法捕捉到了,所以这里首先需要在主进程中屏蔽调 <code>SIGCHLD</code> 信号,之后注册完成之后继续取消对于 <code>SIGCHLD</code> 信号的屏蔽</li>
<li>利用<code>SIGCHLD</code>的方式回收子进程的一个好处就是可以不再妨碍父进程的工作的情况下进行子进程的回收</li>
</ul>
<h2 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h2><ul>
<li>两类系统调用:<ol>
<li>慢速系统调用: 可能会使进程永远阻塞的一类,如果在阻塞期间受到一个信号,该系统调用就会被中断,不再继续执行(早期),也可以设定系统调用是否重启,比如<code>read</code> , <code>write</code> , <code>pause</code> , <code>wait</code>(子进程不死,就会一直阻塞) …</li>
<li>其他系统调用: <code>getpid</code> <code>getppid</code> <code>fork</code> …</li>
</ol>
</li>
<li>满足系统调用被中断的相关行为,其实都是<code>pause</code> 的行为,比如<code>read</code> <ul>
<li>想要中断<code>pause</code>, 信号不可以被屏蔽</li>
<li>信号的处理方式必须是捕捉(默认,忽略都不可以)</li>
<li>中断之后返回 <code>-1</code>, 设置 <code>errorno</code>为<code>EINTR</code> (表示 “被信号中断”)</li>
</ul>
</li>
<li>可以修改<code>sa_flags</code>参数来设置被信号中断之后,系统调用是否重启,<code>SA_INTERRURT</code> 表示不重启,<code>SA_RESTART</code>表示重启</li>
<li>拓展了解:<ul>
<li><code>sa_flags</code>还有很多可选参数,适用于不同的情况,比如捕捉到信号之后,在执行捕捉函数的期间,不希望自动阻塞该信号,可以将<code>sa_flags</code>设置为<code>SA_NODERER</code>,除非<code>sa_mask</code>中包含这一个信号</li>
</ul>
</li>
<li>如果想要给捕捉信号发送结构体等类型,需要(<code>sa_flags</code>)传递 <code>SIGINFO</code> 参数</li>
</ul>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><ul>
<li>会话: 表示用户和操作系统进行交互的一段时间,<code>Linux</code>下的体现就是终端</li>
<li>创建一个会话需要注意以下<code>6</code>点:<ul>
<li>调用进程不可以是进程组组长,该进程变成会话首进程(<code>session header</code>)</li>
<li>该进程成为一个新进程组组长的组长进程</li>
<li>需要有<code>root</code>权限(<code>ubuntu</code>不需要)</li>
<li>新的会话丢弃原有的控制终端,该会话没有控制终端</li>
<li>该调用进程未组长进程,就会出错返回</li>
<li>建立新的会话的时候,首先调用 <code>fork</code> , 父进程终止,子进程调用 <code>setsid()</code></li>
</ul>
</li>
</ul>
<h3 id="getsid函数"><a href="#getsid函数" class="headerlink" title="getsid函数"></a>getsid函数</h3><ul>
<li>获取进程所属的会话 <code>ID</code><ul>
<li><code>pid_t getsid(pid_t pid)</code></li>
<li>成功返回调用进程的会话<code>ID</code>,失败就会返回 <code>-1</code> 并且设置 <code>errorno</code></li>
</ul>
</li>
</ul>
<h3 id="setsid函数"><a href="#setsid函数" class="headerlink" title="setsid函数"></a>setsid函数</h3><ul>
<li>作用: 创建一个会话,并且使用自己的<code>ID</code>设置进程组<code>ID</code>,同时也是新会话的<code>ID</code></li>
<li>函数原型:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li>返回值:<ul>
<li>成功返回调用进程的会话<code>ID</code></li>
<li>失败返回 <code>-1</code> 并且设置 <code>errorno</code></li>
</ul>
</li>
<li><code>ps ajx</code> 命令中的 <code>SID TTY</code> 就是会话 <code>id</code></li>
<li>利用子进程调用会话之后可以得到:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid  = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am father , my pid is %d \n&quot;</span> , getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 表示子进程</span></span><br><span class="line">        <span class="comment">// 首先查看 sid</span></span><br><span class="line">        <span class="type">int</span> old_sid = getsid(<span class="number">0</span>); <span class="comment">// 表示查看当前进程的 sid</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;old_sid = %d \n &quot;</span> , old_sid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;group id = %d \n&quot;</span> , getpgid(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;old_pid = %d \n&quot;</span> , getpid());</span><br><span class="line">        setsid(); <span class="comment">// 表示开启新的会话</span></span><br><span class="line">        <span class="type">int</span> new_sid = getsid(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;new_sid = %d \n &quot;</span> , new_sid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;group id = %d \n&quot;</span> , getpgid(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;new_pid = %d \n&quot;</span> , getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>调用结果如下:<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I am father , my pid is 99089 </span><br><span class="line">old_sid = 98861 </span><br><span class="line"> group id = 99089 </span><br><span class="line">old_pid = 99090 </span><br><span class="line">new_sid = 99090 </span><br><span class="line"> group id = 99090 </span><br><span class="line">new_pid = 99090 </span><br></pre></td></tr></table></figure></li>
<li>可见,用于创建会话的进程首先使用自己的<code>pid</code>创建会话,同时以自己的<code>pid</code>命名进程组并且成为进程组的组长</li>
</ul>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><ul>
<li><code>Daemon</code>(精灵)守护进程,是<code>Linux</code>中后台服务进程,通常独立于控制终端并且周期性执行某种任务或者等待某些发生的事件,一般都是采用 <code>d</code> 结尾的名称命名</li>
<li><code>Linux</code>后台的一些系统服务进程,没有控制终端,不可以直接和用户进行交互,不受用户登陆,注销的影响,一直在运行着,他们都是守护进程,比如预读入缓输出机制的实现: <code>ftp</code>服务器,<code>nfs</code>服务器等</li>
<li>创建守护进程,最关键的一部就是调用 <code>setsid</code> 函数创建一个新的<code>Session</code>并且成为 <code>Session leader</code></li>
</ul>
<h3 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h3><ul>
<li>创建守护进程流程分析:<ul>
<li>创建子进程,父进程退出(所有工作在子进程中进行形式脱离了控制终端)</li>
<li>在子进程中创建新会话(<code>setsid()</code>函数,使得子进程完全独立出来,脱离控制)</li>
<li>改变当前目录位置(<code>chdir()</code>函数,防止占用可以卸载的文件系统(比如<code>U</code>盘等),可以换成其他目录(最好固定比如<code>~</code>或者<code>/</code>))</li>
<li>设置文件权限掩码(<code>umask()</code>函数,防止继承的文件创建屏蔽字拒绝某些权限,增加守护进程灵活性)</li>
<li>关闭文件描述符(标准输入标准输出等)(继承的打开文件不会用到,浪费系统资源,无法卸载)(或者重定向给<code>/dev/null</code>(空洞))</li>
<li>开始执行守护进程核心工作,守护进程退出处理程序模型</li>
</ul>
</li>
</ul>
<h4 id="创建守护进程实现方式"><a href="#创建守护进程实现方式" class="headerlink" title="创建守护进程实现方式"></a>创建守护进程实现方式</h4><ul>
<li>相当于创建了一个后台运行的一个程序</li>
<li>创建代码如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 首先创建子进程</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 等待父进程退出</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 2. 创建会话</span></span><br><span class="line">        ret = setsid();</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;setsid() error &quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 改变工作目录</span></span><br><span class="line">        ret = chdir(<span class="string">&quot;/home/loser&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;chdir() error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 设置 umask</span></span><br><span class="line">        </span><br><span class="line">        umask(<span class="number">0022</span>); <span class="comment">// 由于新创建的文件没有执行权限,所以需要利用这一掩码 权限 &amp; ~umask</span></span><br><span class="line">        <span class="comment">// 5. 进行输入输出重定向或者关闭</span></span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span> , O_RDWR);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;open() failed &quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(STDIN_FILENO); <span class="comment">// 关闭文件描述符 0 </span></span><br><span class="line">        dup2(fd , STDOUT_FILENO);</span><br><span class="line">        dup2(fd , STDERR_FILENO);</span><br><span class="line">        <span class="comment">// 6. 处理核心业务逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 模拟守护进行的业务逻辑</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意文件掩饰代码的设置,可以参考: <a target="_blank" rel="noopener" href="https://blog.csdn.net/2401_84967954/article/details/138983541">https://blog.csdn.net/2401_84967954/article/details/138983541</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xzwsloser.github.io">xzw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xzwsloser.github.io/2024/08/27/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/">https://xzwsloser.github.io/2024/08/27/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xzwsloser.github.io" target="_blank">xzw の 的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/">进程编程</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=2477205961,1650218332&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/08/25/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/" title="文件IO编程"><img class="cover" src="https://img1.baidu.com/it/u=706797935,3702699894&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">文件IO编程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xzw</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xzwsloser"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xzwsloser" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/3088655042@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E4%BB%A5%E5%8F%8ACPU%E7%9B%B8%E5%85%B3"><span class="toc-number">1.1.</span> <span class="toc-text">进程和程序以及CPU相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">虚拟内存和物理内存的映射关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">PCB进程控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">环境变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fork%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">fork函数原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getpid-%E5%92%8C-getppid"><span class="toc-number">2.2.</span> <span class="toc-text">getpid 和 getppid</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">循环创建子进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB"><span class="toc-number">2.4.</span> <span class="toc-text">进程共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB"><span class="toc-number">2.4.1.</span> <span class="toc-text">父子进程共享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B-gdb-%E8%B0%83%E8%AF%95"><span class="toc-number">2.5.</span> <span class="toc-text">父子进程 gdb 调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec-%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">2.6.</span> <span class="toc-text">exec 函数族</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execl-%E5%92%8C-execlp-%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.1.</span> <span class="toc-text">execl 和 execlp 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#execlp%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">execlp函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execl-%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">execl 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.1.3.</span> <span class="toc-text">其他函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">回收子进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.7.1.</span> <span class="toc-text">孤儿进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.7.2.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.3.</span> <span class="toc-text">wait 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%80%BC%E5%92%8C%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">获取子进程退出值和异常终止信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.4.</span> <span class="toc-text">waitpid函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-waitpid-%E5%9B%9E%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.7.5.</span> <span class="toc-text">利用 waitpid 回收多个子进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">2.7.6.</span> <span class="toc-text">综合案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">进程间通信方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93-pipe"><span class="toc-number">3.1.</span> <span class="toc-text">匿名管道(pipe)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.1.1.</span> <span class="toc-text">管道的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">pipe函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.1.3.</span> <span class="toc-text">管道的读写行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%84%E5%BC%9F%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">3.1.4.</span> <span class="toc-text">兄弟进程之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E8%AF%BB%E5%86%99%E7%AB%AF%E6%93%8D%E4%BD%9C%E5%92%8C%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.1.5.</span> <span class="toc-text">多个读写端操作和管道缓冲区的大小设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.1.6.</span> <span class="toc-text">管道的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E7%AE%A1%E9%81%93-fifo"><span class="toc-number">3.2.</span> <span class="toc-text">具名管道(fifo)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">创建方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8fifo%E5%AE%9E%E7%8E%B0%E9%9D%9E%E8%A1%80%E7%BC%98%E5%85%B3%E7%B3%BB%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">3.2.2.</span> <span class="toc-text">利用fifo实现非血缘关系进程之间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%94%A8%E4%BA%8E%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">3.2.3.</span> <span class="toc-text">文件用于进程之间的通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84-I-O"><span class="toc-number">3.3.</span> <span class="toc-text">存储映射 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">mmap函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-mmap-%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E5%8C%BA%E5%9F%9F"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">利用 mmap 建立映射区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E4%BD%BF%E7%94%A8%E6%B3%A8%E9%87%8A%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">mmap使用注释事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E5%BB%BA%E7%AB%8B%E7%88%B6%E5%AD%90%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">mmap建立父子之间通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E8%BF%9B%E8%A1%8C%E9%9D%9E%E8%A1%80%E7%BC%98%E5%85%B3%E7%B3%BB%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">mmap进行非血缘关系进程之间通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E5%8C%BF%E5%90%8D%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="toc-number">3.3.1.5.</span> <span class="toc-text">mmap匿名映射区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">3.4.</span> <span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">信号的机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E7%9A%84%E6%97%B6%E9%97%B4%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">3.4.2.</span> <span class="toc-text">与信号相关的时间和状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%92%8C%E4%BF%A1%E5%8F%B7%E5%9B%9B%E8%A6%81%E7%B4%A0"><span class="toc-number">3.4.3.</span> <span class="toc-text">常见的信号和信号四要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kill%E5%87%BD%E6%95%B0%E4%B8%8Ekill%E5%91%BD%E4%BB%A4"><span class="toc-number">3.4.4.</span> <span class="toc-text">kill函数与kill命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kill%E5%91%BD%E4%BB%A4"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">kill命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kill%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">kill函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alarm%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.5.</span> <span class="toc-text">alarm函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setitimer%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.6.</span> <span class="toc-text">setitimer函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.7.</span> <span class="toc-text">信号集操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sigprocmask-%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.7.1.</span> <span class="toc-text">sigprocmask 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigpending%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.7.2.</span> <span class="toc-text">sigpending函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="toc-number">3.4.8.</span> <span class="toc-text">信号捕捉</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#signal%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.8.1.</span> <span class="toc-text">signal函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigaction%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.8.2.</span> <span class="toc-text">sigaction函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E7%89%B9%E6%80%A7"><span class="toc-number">3.4.8.3.</span> <span class="toc-text">信号捕捉特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E6%8D%95%E6%8D%89%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.8.4.</span> <span class="toc-text">内核实现进程捕捉的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="toc-number">3.4.9.</span> <span class="toc-text">SIGCHLD信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-SIGCHLD-%E4%BF%A1%E5%8F%B7%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.4.9.1.</span> <span class="toc-text">使用 SIGCHLD 信号回收子进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text">中断系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-number">3.6.</span> <span class="toc-text">会话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getsid%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.1.</span> <span class="toc-text">getsid函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setsid%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.2.</span> <span class="toc-text">setsid函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.7.</span> <span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.7.1.</span> <span class="toc-text">创建守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">创建守护进程实现方式</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/27/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="进程编程"><img src="https://img2.baidu.com/it/u=2477205961,1650218332&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程编程"/></a><div class="content"><a class="title" href="/2024/08/27/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/" title="进程编程">进程编程</a><time datetime="2024-08-27T14:46:45.866Z" title="发表于 2024-08-27 22:46:45">2024-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/25/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/" title="文件IO编程"><img src="https://img1.baidu.com/it/u=706797935,3702699894&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=889&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件IO编程"/></a><div class="content"><a class="title" href="/2024/08/25/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/" title="文件IO编程">文件IO编程</a><time datetime="2024-08-25T08:00:02.497Z" title="发表于 2024-08-25 16:00:02">2024-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/24/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%B7%A5%E5%85%B7%E9%93%BE/" title="编译,调试工具链"><img src="https://img1.baidu.com/it/u=2525231642,2721528165&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=1082" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="编译,调试工具链"/></a><div class="content"><a class="title" href="/2024/08/24/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%B7%A5%E5%85%B7%E9%93%BE/" title="编译,调试工具链">编译,调试工具链</a><time datetime="2024-08-24T08:37:40.678Z" title="发表于 2024-08-24 16:37:40">2024-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/24/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%9B%9E%E9%A1%BE/" title="Linux基础"><img src="https://img2.baidu.com/it/u=1854076240,1399178116&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=888" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux基础"/></a><div class="content"><a class="title" href="/2024/08/24/2024-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%9B%9E%E9%A1%BE/" title="Linux基础">Linux基础</a><time datetime="2024-08-24T08:37:40.664Z" title="发表于 2024-08-24 16:37:40">2024-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/22/2024-linux%E5%9F%BA%E7%A1%80-shell%E7%BC%96%E7%A8%8B/" title="shell编程"><img src="https://img1.baidu.com/it/u=3942429818,2071392539&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=1062" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shell编程"/></a><div class="content"><a class="title" href="/2024/08/22/2024-linux%E5%9F%BA%E7%A1%80-shell%E7%BC%96%E7%A8%8B/" title="shell编程">shell编程</a><time datetime="2024-08-22T15:09:13.654Z" title="发表于 2024-08-22 23:09:13">2024-08-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By xzw</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>